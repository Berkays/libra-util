// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `get_with_proof.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct UpdateToLatestLedgerRequest {
    // message fields
    pub client_known_version: u64,
    pub requested_items: ::protobuf::RepeatedField<RequestItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateToLatestLedgerRequest {
    fn default() -> &'a UpdateToLatestLedgerRequest {
        <UpdateToLatestLedgerRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateToLatestLedgerRequest {
    pub fn new() -> UpdateToLatestLedgerRequest {
        ::std::default::Default::default()
    }

    // uint64 client_known_version = 1;


    pub fn get_client_known_version(&self) -> u64 {
        self.client_known_version
    }
    pub fn clear_client_known_version(&mut self) {
        self.client_known_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_client_known_version(&mut self, v: u64) {
        self.client_known_version = v;
    }

    // repeated .types.RequestItem requested_items = 2;


    pub fn get_requested_items(&self) -> &[RequestItem] {
        &self.requested_items
    }
    pub fn clear_requested_items(&mut self) {
        self.requested_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_requested_items(&mut self, v: ::protobuf::RepeatedField<RequestItem>) {
        self.requested_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requested_items(&mut self) -> &mut ::protobuf::RepeatedField<RequestItem> {
        &mut self.requested_items
    }

    // Take field
    pub fn take_requested_items(&mut self) -> ::protobuf::RepeatedField<RequestItem> {
        ::std::mem::replace(&mut self.requested_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateToLatestLedgerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.requested_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.client_known_version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requested_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.client_known_version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.client_known_version, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requested_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.client_known_version != 0 {
            os.write_uint64(1, self.client_known_version)?;
        }
        for v in &self.requested_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateToLatestLedgerRequest {
        UpdateToLatestLedgerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "client_known_version",
                    |m: &UpdateToLatestLedgerRequest| { &m.client_known_version },
                    |m: &mut UpdateToLatestLedgerRequest| { &mut m.client_known_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestItem>>(
                    "requested_items",
                    |m: &UpdateToLatestLedgerRequest| { &m.requested_items },
                    |m: &mut UpdateToLatestLedgerRequest| { &mut m.requested_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateToLatestLedgerRequest>(
                    "UpdateToLatestLedgerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateToLatestLedgerRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateToLatestLedgerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateToLatestLedgerRequest,
        };
        unsafe {
            instance.get(UpdateToLatestLedgerRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateToLatestLedgerRequest {
    fn clear(&mut self) {
        self.client_known_version = 0;
        self.requested_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateToLatestLedgerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateToLatestLedgerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestItem {
    // message oneof groups
    pub requested_items: ::std::option::Option<RequestItem_oneof_requested_items>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestItem {
    fn default() -> &'a RequestItem {
        <RequestItem as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestItem_oneof_requested_items {
    get_account_state_request(GetAccountStateRequest),
    get_account_transaction_by_sequence_number_request(GetAccountTransactionBySequenceNumberRequest),
    get_events_by_event_access_path_request(GetEventsByEventAccessPathRequest),
    get_transactions_request(GetTransactionsRequest),
}

impl RequestItem {
    pub fn new() -> RequestItem {
        ::std::default::Default::default()
    }

    // .types.GetAccountStateRequest get_account_state_request = 1;


    pub fn get_get_account_state_request(&self) -> &GetAccountStateRequest {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(ref v)) => v,
            _ => GetAccountStateRequest::default_instance(),
        }
    }
    pub fn clear_get_account_state_request(&mut self) {
        self.requested_items = ::std::option::Option::None;
    }

    pub fn has_get_account_state_request(&self) -> bool {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_account_state_request(&mut self, v: GetAccountStateRequest) {
        self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_account_state_request(&mut self) -> &mut GetAccountStateRequest {
        if let ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(_)) = self.requested_items {
        } else {
            self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(GetAccountStateRequest::new()));
        }
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_account_state_request(&mut self) -> GetAccountStateRequest {
        if self.has_get_account_state_request() {
            match self.requested_items.take() {
                ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetAccountStateRequest::new()
        }
    }

    // .types.GetAccountTransactionBySequenceNumberRequest get_account_transaction_by_sequence_number_request = 2;


    pub fn get_get_account_transaction_by_sequence_number_request(&self) -> &GetAccountTransactionBySequenceNumberRequest {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(ref v)) => v,
            _ => GetAccountTransactionBySequenceNumberRequest::default_instance(),
        }
    }
    pub fn clear_get_account_transaction_by_sequence_number_request(&mut self) {
        self.requested_items = ::std::option::Option::None;
    }

    pub fn has_get_account_transaction_by_sequence_number_request(&self) -> bool {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_account_transaction_by_sequence_number_request(&mut self, v: GetAccountTransactionBySequenceNumberRequest) {
        self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_account_transaction_by_sequence_number_request(&mut self) -> &mut GetAccountTransactionBySequenceNumberRequest {
        if let ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(_)) = self.requested_items {
        } else {
            self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(GetAccountTransactionBySequenceNumberRequest::new()));
        }
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_account_transaction_by_sequence_number_request(&mut self) -> GetAccountTransactionBySequenceNumberRequest {
        if self.has_get_account_transaction_by_sequence_number_request() {
            match self.requested_items.take() {
                ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetAccountTransactionBySequenceNumberRequest::new()
        }
    }

    // .types.GetEventsByEventAccessPathRequest get_events_by_event_access_path_request = 3;


    pub fn get_get_events_by_event_access_path_request(&self) -> &GetEventsByEventAccessPathRequest {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(ref v)) => v,
            _ => GetEventsByEventAccessPathRequest::default_instance(),
        }
    }
    pub fn clear_get_events_by_event_access_path_request(&mut self) {
        self.requested_items = ::std::option::Option::None;
    }

    pub fn has_get_events_by_event_access_path_request(&self) -> bool {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_events_by_event_access_path_request(&mut self, v: GetEventsByEventAccessPathRequest) {
        self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_events_by_event_access_path_request(&mut self) -> &mut GetEventsByEventAccessPathRequest {
        if let ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(_)) = self.requested_items {
        } else {
            self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(GetEventsByEventAccessPathRequest::new()));
        }
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_events_by_event_access_path_request(&mut self) -> GetEventsByEventAccessPathRequest {
        if self.has_get_events_by_event_access_path_request() {
            match self.requested_items.take() {
                ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetEventsByEventAccessPathRequest::new()
        }
    }

    // .types.GetTransactionsRequest get_transactions_request = 4;


    pub fn get_get_transactions_request(&self) -> &GetTransactionsRequest {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(ref v)) => v,
            _ => GetTransactionsRequest::default_instance(),
        }
    }
    pub fn clear_get_transactions_request(&mut self) {
        self.requested_items = ::std::option::Option::None;
    }

    pub fn has_get_transactions_request(&self) -> bool {
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_transactions_request(&mut self, v: GetTransactionsRequest) {
        self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_transactions_request(&mut self) -> &mut GetTransactionsRequest {
        if let ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(_)) = self.requested_items {
        } else {
            self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(GetTransactionsRequest::new()));
        }
        match self.requested_items {
            ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_transactions_request(&mut self) -> GetTransactionsRequest {
        if self.has_get_transactions_request() {
            match self.requested_items.take() {
                ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTransactionsRequest::new()
        }
    }
}

impl ::protobuf::Message for RequestItem {
    fn is_initialized(&self) -> bool {
        if let Some(RequestItem_oneof_requested_items::get_account_state_request(ref v)) = self.requested_items {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(ref v)) = self.requested_items {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(ref v)) = self.requested_items {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestItem_oneof_requested_items::get_transactions_request(ref v)) = self.requested_items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_state_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_events_by_event_access_path_request(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requested_items = ::std::option::Option::Some(RequestItem_oneof_requested_items::get_transactions_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.requested_items {
            match v {
                &RequestItem_oneof_requested_items::get_account_state_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestItem_oneof_requested_items::get_events_by_event_access_path_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestItem_oneof_requested_items::get_transactions_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.requested_items {
            match v {
                &RequestItem_oneof_requested_items::get_account_state_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestItem_oneof_requested_items::get_account_transaction_by_sequence_number_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestItem_oneof_requested_items::get_events_by_event_access_path_request(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestItem_oneof_requested_items::get_transactions_request(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestItem {
        RequestItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetAccountStateRequest>(
                    "get_account_state_request",
                    RequestItem::has_get_account_state_request,
                    RequestItem::get_get_account_state_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetAccountTransactionBySequenceNumberRequest>(
                    "get_account_transaction_by_sequence_number_request",
                    RequestItem::has_get_account_transaction_by_sequence_number_request,
                    RequestItem::get_get_account_transaction_by_sequence_number_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetEventsByEventAccessPathRequest>(
                    "get_events_by_event_access_path_request",
                    RequestItem::has_get_events_by_event_access_path_request,
                    RequestItem::get_get_events_by_event_access_path_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetTransactionsRequest>(
                    "get_transactions_request",
                    RequestItem::has_get_transactions_request,
                    RequestItem::get_get_transactions_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestItem>(
                    "RequestItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequestItem {
        static mut instance: ::protobuf::lazy::Lazy<RequestItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestItem,
        };
        unsafe {
            instance.get(RequestItem::new)
        }
    }
}

impl ::protobuf::Clear for RequestItem {
    fn clear(&mut self) {
        self.requested_items = ::std::option::Option::None;
        self.requested_items = ::std::option::Option::None;
        self.requested_items = ::std::option::Option::None;
        self.requested_items = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateToLatestLedgerResponse {
    // message fields
    pub response_items: ::protobuf::RepeatedField<ResponseItem>,
    pub ledger_info_with_sigs: ::protobuf::SingularPtrField<super::ledger_info::LedgerInfoWithSignatures>,
    pub validator_change_events: ::protobuf::RepeatedField<super::validator_change::ValidatorChangeEventWithProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateToLatestLedgerResponse {
    fn default() -> &'a UpdateToLatestLedgerResponse {
        <UpdateToLatestLedgerResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateToLatestLedgerResponse {
    pub fn new() -> UpdateToLatestLedgerResponse {
        ::std::default::Default::default()
    }

    // repeated .types.ResponseItem response_items = 1;


    pub fn get_response_items(&self) -> &[ResponseItem] {
        &self.response_items
    }
    pub fn clear_response_items(&mut self) {
        self.response_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_items(&mut self, v: ::protobuf::RepeatedField<ResponseItem>) {
        self.response_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_items(&mut self) -> &mut ::protobuf::RepeatedField<ResponseItem> {
        &mut self.response_items
    }

    // Take field
    pub fn take_response_items(&mut self) -> ::protobuf::RepeatedField<ResponseItem> {
        ::std::mem::replace(&mut self.response_items, ::protobuf::RepeatedField::new())
    }

    // .types.LedgerInfoWithSignatures ledger_info_with_sigs = 2;


    pub fn get_ledger_info_with_sigs(&self) -> &super::ledger_info::LedgerInfoWithSignatures {
        self.ledger_info_with_sigs.as_ref().unwrap_or_else(|| super::ledger_info::LedgerInfoWithSignatures::default_instance())
    }
    pub fn clear_ledger_info_with_sigs(&mut self) {
        self.ledger_info_with_sigs.clear();
    }

    pub fn has_ledger_info_with_sigs(&self) -> bool {
        self.ledger_info_with_sigs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledger_info_with_sigs(&mut self, v: super::ledger_info::LedgerInfoWithSignatures) {
        self.ledger_info_with_sigs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledger_info_with_sigs(&mut self) -> &mut super::ledger_info::LedgerInfoWithSignatures {
        if self.ledger_info_with_sigs.is_none() {
            self.ledger_info_with_sigs.set_default();
        }
        self.ledger_info_with_sigs.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledger_info_with_sigs(&mut self) -> super::ledger_info::LedgerInfoWithSignatures {
        self.ledger_info_with_sigs.take().unwrap_or_else(|| super::ledger_info::LedgerInfoWithSignatures::new())
    }

    // repeated .types.ValidatorChangeEventWithProof validator_change_events = 3;


    pub fn get_validator_change_events(&self) -> &[super::validator_change::ValidatorChangeEventWithProof] {
        &self.validator_change_events
    }
    pub fn clear_validator_change_events(&mut self) {
        self.validator_change_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_change_events(&mut self, v: ::protobuf::RepeatedField<super::validator_change::ValidatorChangeEventWithProof>) {
        self.validator_change_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validator_change_events(&mut self) -> &mut ::protobuf::RepeatedField<super::validator_change::ValidatorChangeEventWithProof> {
        &mut self.validator_change_events
    }

    // Take field
    pub fn take_validator_change_events(&mut self) -> ::protobuf::RepeatedField<super::validator_change::ValidatorChangeEventWithProof> {
        ::std::mem::replace(&mut self.validator_change_events, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateToLatestLedgerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ledger_info_with_sigs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.validator_change_events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.response_items)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ledger_info_with_sigs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validator_change_events)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.response_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.ledger_info_with_sigs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.validator_change_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.response_items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.ledger_info_with_sigs.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.validator_change_events {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateToLatestLedgerResponse {
        UpdateToLatestLedgerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseItem>>(
                    "response_items",
                    |m: &UpdateToLatestLedgerResponse| { &m.response_items },
                    |m: &mut UpdateToLatestLedgerResponse| { &mut m.response_items },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::ledger_info::LedgerInfoWithSignatures>>(
                    "ledger_info_with_sigs",
                    |m: &UpdateToLatestLedgerResponse| { &m.ledger_info_with_sigs },
                    |m: &mut UpdateToLatestLedgerResponse| { &mut m.ledger_info_with_sigs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::validator_change::ValidatorChangeEventWithProof>>(
                    "validator_change_events",
                    |m: &UpdateToLatestLedgerResponse| { &m.validator_change_events },
                    |m: &mut UpdateToLatestLedgerResponse| { &mut m.validator_change_events },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateToLatestLedgerResponse>(
                    "UpdateToLatestLedgerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateToLatestLedgerResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdateToLatestLedgerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateToLatestLedgerResponse,
        };
        unsafe {
            instance.get(UpdateToLatestLedgerResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdateToLatestLedgerResponse {
    fn clear(&mut self) {
        self.response_items.clear();
        self.ledger_info_with_sigs.clear();
        self.validator_change_events.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateToLatestLedgerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateToLatestLedgerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseItem {
    // message oneof groups
    pub response_items: ::std::option::Option<ResponseItem_oneof_response_items>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseItem {
    fn default() -> &'a ResponseItem {
        <ResponseItem as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ResponseItem_oneof_response_items {
    get_account_state_response(GetAccountStateResponse),
    get_account_transaction_by_sequence_number_response(GetAccountTransactionBySequenceNumberResponse),
    get_events_by_event_access_path_response(GetEventsByEventAccessPathResponse),
    get_transactions_response(GetTransactionsResponse),
}

impl ResponseItem {
    pub fn new() -> ResponseItem {
        ::std::default::Default::default()
    }

    // .types.GetAccountStateResponse get_account_state_response = 3;


    pub fn get_get_account_state_response(&self) -> &GetAccountStateResponse {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(ref v)) => v,
            _ => GetAccountStateResponse::default_instance(),
        }
    }
    pub fn clear_get_account_state_response(&mut self) {
        self.response_items = ::std::option::Option::None;
    }

    pub fn has_get_account_state_response(&self) -> bool {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_account_state_response(&mut self, v: GetAccountStateResponse) {
        self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_account_state_response(&mut self) -> &mut GetAccountStateResponse {
        if let ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(_)) = self.response_items {
        } else {
            self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(GetAccountStateResponse::new()));
        }
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_account_state_response(&mut self) -> GetAccountStateResponse {
        if self.has_get_account_state_response() {
            match self.response_items.take() {
                ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetAccountStateResponse::new()
        }
    }

    // .types.GetAccountTransactionBySequenceNumberResponse get_account_transaction_by_sequence_number_response = 4;


    pub fn get_get_account_transaction_by_sequence_number_response(&self) -> &GetAccountTransactionBySequenceNumberResponse {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(ref v)) => v,
            _ => GetAccountTransactionBySequenceNumberResponse::default_instance(),
        }
    }
    pub fn clear_get_account_transaction_by_sequence_number_response(&mut self) {
        self.response_items = ::std::option::Option::None;
    }

    pub fn has_get_account_transaction_by_sequence_number_response(&self) -> bool {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_account_transaction_by_sequence_number_response(&mut self, v: GetAccountTransactionBySequenceNumberResponse) {
        self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_account_transaction_by_sequence_number_response(&mut self) -> &mut GetAccountTransactionBySequenceNumberResponse {
        if let ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(_)) = self.response_items {
        } else {
            self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(GetAccountTransactionBySequenceNumberResponse::new()));
        }
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_account_transaction_by_sequence_number_response(&mut self) -> GetAccountTransactionBySequenceNumberResponse {
        if self.has_get_account_transaction_by_sequence_number_response() {
            match self.response_items.take() {
                ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetAccountTransactionBySequenceNumberResponse::new()
        }
    }

    // .types.GetEventsByEventAccessPathResponse get_events_by_event_access_path_response = 5;


    pub fn get_get_events_by_event_access_path_response(&self) -> &GetEventsByEventAccessPathResponse {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(ref v)) => v,
            _ => GetEventsByEventAccessPathResponse::default_instance(),
        }
    }
    pub fn clear_get_events_by_event_access_path_response(&mut self) {
        self.response_items = ::std::option::Option::None;
    }

    pub fn has_get_events_by_event_access_path_response(&self) -> bool {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_events_by_event_access_path_response(&mut self, v: GetEventsByEventAccessPathResponse) {
        self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_events_by_event_access_path_response(&mut self) -> &mut GetEventsByEventAccessPathResponse {
        if let ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(_)) = self.response_items {
        } else {
            self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(GetEventsByEventAccessPathResponse::new()));
        }
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_events_by_event_access_path_response(&mut self) -> GetEventsByEventAccessPathResponse {
        if self.has_get_events_by_event_access_path_response() {
            match self.response_items.take() {
                ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetEventsByEventAccessPathResponse::new()
        }
    }

    // .types.GetTransactionsResponse get_transactions_response = 6;


    pub fn get_get_transactions_response(&self) -> &GetTransactionsResponse {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(ref v)) => v,
            _ => GetTransactionsResponse::default_instance(),
        }
    }
    pub fn clear_get_transactions_response(&mut self) {
        self.response_items = ::std::option::Option::None;
    }

    pub fn has_get_transactions_response(&self) -> bool {
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_transactions_response(&mut self, v: GetTransactionsResponse) {
        self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_transactions_response(&mut self) -> &mut GetTransactionsResponse {
        if let ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(_)) = self.response_items {
        } else {
            self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(GetTransactionsResponse::new()));
        }
        match self.response_items {
            ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_transactions_response(&mut self) -> GetTransactionsResponse {
        if self.has_get_transactions_response() {
            match self.response_items.take() {
                ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTransactionsResponse::new()
        }
    }
}

impl ::protobuf::Message for ResponseItem {
    fn is_initialized(&self) -> bool {
        if let Some(ResponseItem_oneof_response_items::get_account_state_response(ref v)) = self.response_items {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(ref v)) = self.response_items {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(ref v)) = self.response_items {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseItem_oneof_response_items::get_transactions_response(ref v)) = self.response_items {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_state_response(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_events_by_event_access_path_response(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_items = ::std::option::Option::Some(ResponseItem_oneof_response_items::get_transactions_response(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response_items {
            match v {
                &ResponseItem_oneof_response_items::get_account_state_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseItem_oneof_response_items::get_events_by_event_access_path_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseItem_oneof_response_items::get_transactions_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response_items {
            match v {
                &ResponseItem_oneof_response_items::get_account_state_response(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseItem_oneof_response_items::get_account_transaction_by_sequence_number_response(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseItem_oneof_response_items::get_events_by_event_access_path_response(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseItem_oneof_response_items::get_transactions_response(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseItem {
        ResponseItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetAccountStateResponse>(
                    "get_account_state_response",
                    ResponseItem::has_get_account_state_response,
                    ResponseItem::get_get_account_state_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetAccountTransactionBySequenceNumberResponse>(
                    "get_account_transaction_by_sequence_number_response",
                    ResponseItem::has_get_account_transaction_by_sequence_number_response,
                    ResponseItem::get_get_account_transaction_by_sequence_number_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetEventsByEventAccessPathResponse>(
                    "get_events_by_event_access_path_response",
                    ResponseItem::has_get_events_by_event_access_path_response,
                    ResponseItem::get_get_events_by_event_access_path_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetTransactionsResponse>(
                    "get_transactions_response",
                    ResponseItem::has_get_transactions_response,
                    ResponseItem::get_get_transactions_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResponseItem>(
                    "ResponseItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResponseItem {
        static mut instance: ::protobuf::lazy::Lazy<ResponseItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResponseItem,
        };
        unsafe {
            instance.get(ResponseItem::new)
        }
    }
}

impl ::protobuf::Clear for ResponseItem {
    fn clear(&mut self) {
        self.response_items = ::std::option::Option::None;
        self.response_items = ::std::option::Option::None;
        self.response_items = ::std::option::Option::None;
        self.response_items = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAccountStateRequest {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountStateRequest {
    fn default() -> &'a GetAccountStateRequest {
        <GetAccountStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountStateRequest {
    pub fn new() -> GetAccountStateRequest {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetAccountStateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountStateRequest {
        GetAccountStateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &GetAccountStateRequest| { &m.address },
                    |m: &mut GetAccountStateRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAccountStateRequest>(
                    "GetAccountStateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAccountStateRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetAccountStateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAccountStateRequest,
        };
        unsafe {
            instance.get(GetAccountStateRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetAccountStateRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccountStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAccountStateResponse {
    // message fields
    pub account_state_with_proof: ::protobuf::SingularPtrField<super::account_state_blob::AccountStateWithProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountStateResponse {
    fn default() -> &'a GetAccountStateResponse {
        <GetAccountStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountStateResponse {
    pub fn new() -> GetAccountStateResponse {
        ::std::default::Default::default()
    }

    // .types.AccountStateWithProof account_state_with_proof = 1;


    pub fn get_account_state_with_proof(&self) -> &super::account_state_blob::AccountStateWithProof {
        self.account_state_with_proof.as_ref().unwrap_or_else(|| super::account_state_blob::AccountStateWithProof::default_instance())
    }
    pub fn clear_account_state_with_proof(&mut self) {
        self.account_state_with_proof.clear();
    }

    pub fn has_account_state_with_proof(&self) -> bool {
        self.account_state_with_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_state_with_proof(&mut self, v: super::account_state_blob::AccountStateWithProof) {
        self.account_state_with_proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_state_with_proof(&mut self) -> &mut super::account_state_blob::AccountStateWithProof {
        if self.account_state_with_proof.is_none() {
            self.account_state_with_proof.set_default();
        }
        self.account_state_with_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_state_with_proof(&mut self) -> super::account_state_blob::AccountStateWithProof {
        self.account_state_with_proof.take().unwrap_or_else(|| super::account_state_blob::AccountStateWithProof::new())
    }
}

impl ::protobuf::Message for GetAccountStateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.account_state_with_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_state_with_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_state_with_proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_state_with_proof.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountStateResponse {
        GetAccountStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::account_state_blob::AccountStateWithProof>>(
                    "account_state_with_proof",
                    |m: &GetAccountStateResponse| { &m.account_state_with_proof },
                    |m: &mut GetAccountStateResponse| { &mut m.account_state_with_proof },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAccountStateResponse>(
                    "GetAccountStateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAccountStateResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetAccountStateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAccountStateResponse,
        };
        unsafe {
            instance.get(GetAccountStateResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetAccountStateResponse {
    fn clear(&mut self) {
        self.account_state_with_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccountStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAccountTransactionBySequenceNumberRequest {
    // message fields
    pub account: ::std::vec::Vec<u8>,
    pub sequence_number: u64,
    pub fetch_events: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountTransactionBySequenceNumberRequest {
    fn default() -> &'a GetAccountTransactionBySequenceNumberRequest {
        <GetAccountTransactionBySequenceNumberRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountTransactionBySequenceNumberRequest {
    pub fn new() -> GetAccountTransactionBySequenceNumberRequest {
        ::std::default::Default::default()
    }

    // bytes account = 1;


    pub fn get_account(&self) -> &[u8] {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::vec::Vec<u8>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account, ::std::vec::Vec::new())
    }

    // uint64 sequence_number = 2;


    pub fn get_sequence_number(&self) -> u64 {
        self.sequence_number
    }
    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: u64) {
        self.sequence_number = v;
    }

    // bool fetch_events = 3;


    pub fn get_fetch_events(&self) -> bool {
        self.fetch_events
    }
    pub fn clear_fetch_events(&mut self) {
        self.fetch_events = false;
    }

    // Param is passed by value, moved
    pub fn set_fetch_events(&mut self, v: bool) {
        self.fetch_events = v;
    }
}

impl ::protobuf::Message for GetAccountTransactionBySequenceNumberRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_number = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fetch_events = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sequence_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fetch_events != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        if self.sequence_number != 0 {
            os.write_uint64(2, self.sequence_number)?;
        }
        if self.fetch_events != false {
            os.write_bool(3, self.fetch_events)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountTransactionBySequenceNumberRequest {
        GetAccountTransactionBySequenceNumberRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account",
                    |m: &GetAccountTransactionBySequenceNumberRequest| { &m.account },
                    |m: &mut GetAccountTransactionBySequenceNumberRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sequence_number",
                    |m: &GetAccountTransactionBySequenceNumberRequest| { &m.sequence_number },
                    |m: &mut GetAccountTransactionBySequenceNumberRequest| { &mut m.sequence_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "fetch_events",
                    |m: &GetAccountTransactionBySequenceNumberRequest| { &m.fetch_events },
                    |m: &mut GetAccountTransactionBySequenceNumberRequest| { &mut m.fetch_events },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAccountTransactionBySequenceNumberRequest>(
                    "GetAccountTransactionBySequenceNumberRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAccountTransactionBySequenceNumberRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetAccountTransactionBySequenceNumberRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAccountTransactionBySequenceNumberRequest,
        };
        unsafe {
            instance.get(GetAccountTransactionBySequenceNumberRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetAccountTransactionBySequenceNumberRequest {
    fn clear(&mut self) {
        self.account.clear();
        self.sequence_number = 0;
        self.fetch_events = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccountTransactionBySequenceNumberRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountTransactionBySequenceNumberRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAccountTransactionBySequenceNumberResponse {
    // message fields
    pub signed_transaction_with_proof: ::protobuf::SingularPtrField<super::transaction::SignedTransactionWithProof>,
    pub proof_of_current_sequence_number: ::protobuf::SingularPtrField<super::account_state_blob::AccountStateWithProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountTransactionBySequenceNumberResponse {
    fn default() -> &'a GetAccountTransactionBySequenceNumberResponse {
        <GetAccountTransactionBySequenceNumberResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountTransactionBySequenceNumberResponse {
    pub fn new() -> GetAccountTransactionBySequenceNumberResponse {
        ::std::default::Default::default()
    }

    // .types.SignedTransactionWithProof signed_transaction_with_proof = 2;


    pub fn get_signed_transaction_with_proof(&self) -> &super::transaction::SignedTransactionWithProof {
        self.signed_transaction_with_proof.as_ref().unwrap_or_else(|| super::transaction::SignedTransactionWithProof::default_instance())
    }
    pub fn clear_signed_transaction_with_proof(&mut self) {
        self.signed_transaction_with_proof.clear();
    }

    pub fn has_signed_transaction_with_proof(&self) -> bool {
        self.signed_transaction_with_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signed_transaction_with_proof(&mut self, v: super::transaction::SignedTransactionWithProof) {
        self.signed_transaction_with_proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signed_transaction_with_proof(&mut self) -> &mut super::transaction::SignedTransactionWithProof {
        if self.signed_transaction_with_proof.is_none() {
            self.signed_transaction_with_proof.set_default();
        }
        self.signed_transaction_with_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_signed_transaction_with_proof(&mut self) -> super::transaction::SignedTransactionWithProof {
        self.signed_transaction_with_proof.take().unwrap_or_else(|| super::transaction::SignedTransactionWithProof::new())
    }

    // .types.AccountStateWithProof proof_of_current_sequence_number = 3;


    pub fn get_proof_of_current_sequence_number(&self) -> &super::account_state_blob::AccountStateWithProof {
        self.proof_of_current_sequence_number.as_ref().unwrap_or_else(|| super::account_state_blob::AccountStateWithProof::default_instance())
    }
    pub fn clear_proof_of_current_sequence_number(&mut self) {
        self.proof_of_current_sequence_number.clear();
    }

    pub fn has_proof_of_current_sequence_number(&self) -> bool {
        self.proof_of_current_sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_of_current_sequence_number(&mut self, v: super::account_state_blob::AccountStateWithProof) {
        self.proof_of_current_sequence_number = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_of_current_sequence_number(&mut self) -> &mut super::account_state_blob::AccountStateWithProof {
        if self.proof_of_current_sequence_number.is_none() {
            self.proof_of_current_sequence_number.set_default();
        }
        self.proof_of_current_sequence_number.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_of_current_sequence_number(&mut self) -> super::account_state_blob::AccountStateWithProof {
        self.proof_of_current_sequence_number.take().unwrap_or_else(|| super::account_state_blob::AccountStateWithProof::new())
    }
}

impl ::protobuf::Message for GetAccountTransactionBySequenceNumberResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.signed_transaction_with_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof_of_current_sequence_number {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signed_transaction_with_proof)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_of_current_sequence_number)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signed_transaction_with_proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.proof_of_current_sequence_number.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signed_transaction_with_proof.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.proof_of_current_sequence_number.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountTransactionBySequenceNumberResponse {
        GetAccountTransactionBySequenceNumberResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::transaction::SignedTransactionWithProof>>(
                    "signed_transaction_with_proof",
                    |m: &GetAccountTransactionBySequenceNumberResponse| { &m.signed_transaction_with_proof },
                    |m: &mut GetAccountTransactionBySequenceNumberResponse| { &mut m.signed_transaction_with_proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::account_state_blob::AccountStateWithProof>>(
                    "proof_of_current_sequence_number",
                    |m: &GetAccountTransactionBySequenceNumberResponse| { &m.proof_of_current_sequence_number },
                    |m: &mut GetAccountTransactionBySequenceNumberResponse| { &mut m.proof_of_current_sequence_number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAccountTransactionBySequenceNumberResponse>(
                    "GetAccountTransactionBySequenceNumberResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAccountTransactionBySequenceNumberResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetAccountTransactionBySequenceNumberResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAccountTransactionBySequenceNumberResponse,
        };
        unsafe {
            instance.get(GetAccountTransactionBySequenceNumberResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetAccountTransactionBySequenceNumberResponse {
    fn clear(&mut self) {
        self.signed_transaction_with_proof.clear();
        self.proof_of_current_sequence_number.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccountTransactionBySequenceNumberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountTransactionBySequenceNumberResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEventsByEventAccessPathRequest {
    // message fields
    pub access_path: ::protobuf::SingularPtrField<super::access_path::AccessPath>,
    pub start_event_seq_num: u64,
    pub ascending: bool,
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEventsByEventAccessPathRequest {
    fn default() -> &'a GetEventsByEventAccessPathRequest {
        <GetEventsByEventAccessPathRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEventsByEventAccessPathRequest {
    pub fn new() -> GetEventsByEventAccessPathRequest {
        ::std::default::Default::default()
    }

    // .types.AccessPath access_path = 1;


    pub fn get_access_path(&self) -> &super::access_path::AccessPath {
        self.access_path.as_ref().unwrap_or_else(|| super::access_path::AccessPath::default_instance())
    }
    pub fn clear_access_path(&mut self) {
        self.access_path.clear();
    }

    pub fn has_access_path(&self) -> bool {
        self.access_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_path(&mut self, v: super::access_path::AccessPath) {
        self.access_path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_path(&mut self) -> &mut super::access_path::AccessPath {
        if self.access_path.is_none() {
            self.access_path.set_default();
        }
        self.access_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_path(&mut self) -> super::access_path::AccessPath {
        self.access_path.take().unwrap_or_else(|| super::access_path::AccessPath::new())
    }

    // uint64 start_event_seq_num = 2;


    pub fn get_start_event_seq_num(&self) -> u64 {
        self.start_event_seq_num
    }
    pub fn clear_start_event_seq_num(&mut self) {
        self.start_event_seq_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_event_seq_num(&mut self, v: u64) {
        self.start_event_seq_num = v;
    }

    // bool ascending = 3;


    pub fn get_ascending(&self) -> bool {
        self.ascending
    }
    pub fn clear_ascending(&mut self) {
        self.ascending = false;
    }

    // Param is passed by value, moved
    pub fn set_ascending(&mut self, v: bool) {
        self.ascending = v;
    }

    // uint64 limit = 4;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for GetEventsByEventAccessPathRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.access_path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.access_path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_event_seq_num = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ascending = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.access_path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_event_seq_num != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_event_seq_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ascending != false {
            my_size += 2;
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.access_path.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_event_seq_num != 0 {
            os.write_uint64(2, self.start_event_seq_num)?;
        }
        if self.ascending != false {
            os.write_bool(3, self.ascending)?;
        }
        if self.limit != 0 {
            os.write_uint64(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEventsByEventAccessPathRequest {
        GetEventsByEventAccessPathRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_path::AccessPath>>(
                    "access_path",
                    |m: &GetEventsByEventAccessPathRequest| { &m.access_path },
                    |m: &mut GetEventsByEventAccessPathRequest| { &mut m.access_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_event_seq_num",
                    |m: &GetEventsByEventAccessPathRequest| { &m.start_event_seq_num },
                    |m: &mut GetEventsByEventAccessPathRequest| { &mut m.start_event_seq_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ascending",
                    |m: &GetEventsByEventAccessPathRequest| { &m.ascending },
                    |m: &mut GetEventsByEventAccessPathRequest| { &mut m.ascending },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &GetEventsByEventAccessPathRequest| { &m.limit },
                    |m: &mut GetEventsByEventAccessPathRequest| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEventsByEventAccessPathRequest>(
                    "GetEventsByEventAccessPathRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEventsByEventAccessPathRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetEventsByEventAccessPathRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEventsByEventAccessPathRequest,
        };
        unsafe {
            instance.get(GetEventsByEventAccessPathRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetEventsByEventAccessPathRequest {
    fn clear(&mut self) {
        self.access_path.clear();
        self.start_event_seq_num = 0;
        self.ascending = false;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEventsByEventAccessPathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEventsByEventAccessPathRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEventsByEventAccessPathResponse {
    // message fields
    pub events_with_proof: ::protobuf::RepeatedField<super::events::EventWithProof>,
    pub proof_of_latest_event: ::protobuf::SingularPtrField<super::account_state_blob::AccountStateWithProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEventsByEventAccessPathResponse {
    fn default() -> &'a GetEventsByEventAccessPathResponse {
        <GetEventsByEventAccessPathResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetEventsByEventAccessPathResponse {
    pub fn new() -> GetEventsByEventAccessPathResponse {
        ::std::default::Default::default()
    }

    // repeated .types.EventWithProof events_with_proof = 1;


    pub fn get_events_with_proof(&self) -> &[super::events::EventWithProof] {
        &self.events_with_proof
    }
    pub fn clear_events_with_proof(&mut self) {
        self.events_with_proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_events_with_proof(&mut self, v: ::protobuf::RepeatedField<super::events::EventWithProof>) {
        self.events_with_proof = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events_with_proof(&mut self) -> &mut ::protobuf::RepeatedField<super::events::EventWithProof> {
        &mut self.events_with_proof
    }

    // Take field
    pub fn take_events_with_proof(&mut self) -> ::protobuf::RepeatedField<super::events::EventWithProof> {
        ::std::mem::replace(&mut self.events_with_proof, ::protobuf::RepeatedField::new())
    }

    // .types.AccountStateWithProof proof_of_latest_event = 2;


    pub fn get_proof_of_latest_event(&self) -> &super::account_state_blob::AccountStateWithProof {
        self.proof_of_latest_event.as_ref().unwrap_or_else(|| super::account_state_blob::AccountStateWithProof::default_instance())
    }
    pub fn clear_proof_of_latest_event(&mut self) {
        self.proof_of_latest_event.clear();
    }

    pub fn has_proof_of_latest_event(&self) -> bool {
        self.proof_of_latest_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_of_latest_event(&mut self, v: super::account_state_blob::AccountStateWithProof) {
        self.proof_of_latest_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_of_latest_event(&mut self) -> &mut super::account_state_blob::AccountStateWithProof {
        if self.proof_of_latest_event.is_none() {
            self.proof_of_latest_event.set_default();
        }
        self.proof_of_latest_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_of_latest_event(&mut self) -> super::account_state_blob::AccountStateWithProof {
        self.proof_of_latest_event.take().unwrap_or_else(|| super::account_state_blob::AccountStateWithProof::new())
    }
}

impl ::protobuf::Message for GetEventsByEventAccessPathResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.events_with_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof_of_latest_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events_with_proof)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_of_latest_event)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events_with_proof {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.proof_of_latest_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events_with_proof {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.proof_of_latest_event.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEventsByEventAccessPathResponse {
        GetEventsByEventAccessPathResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::events::EventWithProof>>(
                    "events_with_proof",
                    |m: &GetEventsByEventAccessPathResponse| { &m.events_with_proof },
                    |m: &mut GetEventsByEventAccessPathResponse| { &mut m.events_with_proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::account_state_blob::AccountStateWithProof>>(
                    "proof_of_latest_event",
                    |m: &GetEventsByEventAccessPathResponse| { &m.proof_of_latest_event },
                    |m: &mut GetEventsByEventAccessPathResponse| { &mut m.proof_of_latest_event },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEventsByEventAccessPathResponse>(
                    "GetEventsByEventAccessPathResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEventsByEventAccessPathResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetEventsByEventAccessPathResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEventsByEventAccessPathResponse,
        };
        unsafe {
            instance.get(GetEventsByEventAccessPathResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetEventsByEventAccessPathResponse {
    fn clear(&mut self) {
        self.events_with_proof.clear();
        self.proof_of_latest_event.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEventsByEventAccessPathResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEventsByEventAccessPathResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTransactionsRequest {
    // message fields
    pub start_version: u64,
    pub limit: u64,
    pub fetch_events: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTransactionsRequest {
    fn default() -> &'a GetTransactionsRequest {
        <GetTransactionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionsRequest {
    pub fn new() -> GetTransactionsRequest {
        ::std::default::Default::default()
    }

    // uint64 start_version = 1;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // uint64 limit = 2;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    // bool fetch_events = 3;


    pub fn get_fetch_events(&self) -> bool {
        self.fetch_events
    }
    pub fn clear_fetch_events(&mut self) {
        self.fetch_events = false;
    }

    // Param is passed by value, moved
    pub fn set_fetch_events(&mut self, v: bool) {
        self.fetch_events = v;
    }
}

impl ::protobuf::Message for GetTransactionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fetch_events = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fetch_events != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_version != 0 {
            os.write_uint64(1, self.start_version)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        if self.fetch_events != false {
            os.write_bool(3, self.fetch_events)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTransactionsRequest {
        GetTransactionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_version",
                    |m: &GetTransactionsRequest| { &m.start_version },
                    |m: &mut GetTransactionsRequest| { &mut m.start_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &GetTransactionsRequest| { &m.limit },
                    |m: &mut GetTransactionsRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "fetch_events",
                    |m: &GetTransactionsRequest| { &m.fetch_events },
                    |m: &mut GetTransactionsRequest| { &mut m.fetch_events },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTransactionsRequest>(
                    "GetTransactionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTransactionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetTransactionsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTransactionsRequest,
        };
        unsafe {
            instance.get(GetTransactionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetTransactionsRequest {
    fn clear(&mut self) {
        self.start_version = 0;
        self.limit = 0;
        self.fetch_events = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTransactionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTransactionsResponse {
    // message fields
    pub txn_list_with_proof: ::protobuf::SingularPtrField<super::transaction::TransactionListWithProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTransactionsResponse {
    fn default() -> &'a GetTransactionsResponse {
        <GetTransactionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionsResponse {
    pub fn new() -> GetTransactionsResponse {
        ::std::default::Default::default()
    }

    // .types.TransactionListWithProof txn_list_with_proof = 1;


    pub fn get_txn_list_with_proof(&self) -> &super::transaction::TransactionListWithProof {
        self.txn_list_with_proof.as_ref().unwrap_or_else(|| super::transaction::TransactionListWithProof::default_instance())
    }
    pub fn clear_txn_list_with_proof(&mut self) {
        self.txn_list_with_proof.clear();
    }

    pub fn has_txn_list_with_proof(&self) -> bool {
        self.txn_list_with_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_list_with_proof(&mut self, v: super::transaction::TransactionListWithProof) {
        self.txn_list_with_proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_list_with_proof(&mut self) -> &mut super::transaction::TransactionListWithProof {
        if self.txn_list_with_proof.is_none() {
            self.txn_list_with_proof.set_default();
        }
        self.txn_list_with_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_list_with_proof(&mut self) -> super::transaction::TransactionListWithProof {
        self.txn_list_with_proof.take().unwrap_or_else(|| super::transaction::TransactionListWithProof::new())
    }
}

impl ::protobuf::Message for GetTransactionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.txn_list_with_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.txn_list_with_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.txn_list_with_proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.txn_list_with_proof.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTransactionsResponse {
        GetTransactionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::transaction::TransactionListWithProof>>(
                    "txn_list_with_proof",
                    |m: &GetTransactionsResponse| { &m.txn_list_with_proof },
                    |m: &mut GetTransactionsResponse| { &mut m.txn_list_with_proof },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTransactionsResponse>(
                    "GetTransactionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTransactionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetTransactionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTransactionsResponse,
        };
        unsafe {
            instance.get(GetTransactionsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetTransactionsResponse {
    fn clear(&mut self) {
        self.txn_list_with_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTransactionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14get_with_proof.proto\x12\x05types\x1a\x11access_path.proto\x1a\x18\
    account_state_blob.proto\x1a\x0cevents.proto\x1a\x11ledger_info.proto\
    \x1a\x11transaction.proto\x1a\x16validator_change.proto\"\x8c\x01\n\x1bU\
    pdateToLatestLedgerRequest\x120\n\x14client_known_version\x18\x01\x20\
    \x01(\x04R\x12clientKnownVersion\x12;\n\x0frequested_items\x18\x02\x20\
    \x03(\x0b2\x12.types.RequestItemR\x0erequestedItems\"\xf9\x03\n\x0bReque\
    stItem\x12Z\n\x19get_account_state_request\x18\x01\x20\x01(\x0b2\x1d.typ\
    es.GetAccountStateRequestH\0R\x16getAccountStateRequest\x12\x9f\x01\n2ge\
    t_account_transaction_by_sequence_number_request\x18\x02\x20\x01(\x0b23.\
    types.GetAccountTransactionBySequenceNumberRequestH\0R,getAccountTransac\
    tionBySequenceNumberRequest\x12~\n'get_events_by_event_access_path_reque\
    st\x18\x03\x20\x01(\x0b2(.types.GetEventsByEventAccessPathRequestH\0R!ge\
    tEventsByEventAccessPathRequest\x12Y\n\x18get_transactions_request\x18\
    \x04\x20\x01(\x0b2\x1d.types.GetTransactionsRequestH\0R\x16getTransactio\
    nsRequestB\x11\n\x0frequested_items\"\x8c\x02\n\x1cUpdateToLatestLedgerR\
    esponse\x12:\n\x0eresponse_items\x18\x01\x20\x03(\x0b2\x13.types.Respons\
    eItemR\rresponseItems\x12R\n\x15ledger_info_with_sigs\x18\x02\x20\x01(\
    \x0b2\x1f.types.LedgerInfoWithSignaturesR\x12ledgerInfoWithSigs\x12\\\n\
    \x17validator_change_events\x18\x03\x20\x03(\x0b2$.types.ValidatorChange\
    EventWithProofR\x15validatorChangeEvents\"\x86\x04\n\x0cResponseItem\x12\
    ]\n\x1aget_account_state_response\x18\x03\x20\x01(\x0b2\x1e.types.GetAcc\
    ountStateResponseH\0R\x17getAccountStateResponse\x12\xa2\x01\n3get_accou\
    nt_transaction_by_sequence_number_response\x18\x04\x20\x01(\x0b24.types.\
    GetAccountTransactionBySequenceNumberResponseH\0R-getAccountTransactionB\
    ySequenceNumberResponse\x12\x81\x01\n(get_events_by_event_access_path_re\
    sponse\x18\x05\x20\x01(\x0b2).types.GetEventsByEventAccessPathResponseH\
    \0R\"getEventsByEventAccessPathResponse\x12\\\n\x19get_transactions_resp\
    onse\x18\x06\x20\x01(\x0b2\x1e.types.GetTransactionsResponseH\0R\x17getT\
    ransactionsResponseB\x10\n\x0eresponse_items\"2\n\x16GetAccountStateRequ\
    est\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\"p\n\x17GetAcc\
    ountStateResponse\x12U\n\x18account_state_with_proof\x18\x01\x20\x01(\
    \x0b2\x1c.types.AccountStateWithProofR\x15accountStateWithProof\"\x94\
    \x01\n,GetAccountTransactionBySequenceNumberRequest\x12\x18\n\x07account\
    \x18\x01\x20\x01(\x0cR\x07account\x12'\n\x0fsequence_number\x18\x02\x20\
    \x01(\x04R\x0esequenceNumber\x12!\n\x0cfetch_events\x18\x03\x20\x01(\x08\
    R\x0bfetchEvents\"\xfb\x01\n-GetAccountTransactionBySequenceNumberRespon\
    se\x12d\n\x1dsigned_transaction_with_proof\x18\x02\x20\x01(\x0b2!.types.\
    SignedTransactionWithProofR\x1asignedTransactionWithProof\x12d\n\x20proo\
    f_of_current_sequence_number\x18\x03\x20\x01(\x0b2\x1c.types.AccountStat\
    eWithProofR\x1cproofOfCurrentSequenceNumber\"\xba\x01\n!GetEventsByEvent\
    AccessPathRequest\x122\n\x0baccess_path\x18\x01\x20\x01(\x0b2\x11.types.\
    AccessPathR\naccessPath\x12-\n\x13start_event_seq_num\x18\x02\x20\x01(\
    \x04R\x10startEventSeqNum\x12\x1c\n\tascending\x18\x03\x20\x01(\x08R\tas\
    cending\x12\x14\n\x05limit\x18\x04\x20\x01(\x04R\x05limit\"\xb8\x01\n\"G\
    etEventsByEventAccessPathResponse\x12A\n\x11events_with_proof\x18\x01\
    \x20\x03(\x0b2\x15.types.EventWithProofR\x0feventsWithProof\x12O\n\x15pr\
    oof_of_latest_event\x18\x02\x20\x01(\x0b2\x1c.types.AccountStateWithProo\
    fR\x12proofOfLatestEvent\"v\n\x16GetTransactionsRequest\x12#\n\rstart_ve\
    rsion\x18\x01\x20\x01(\x04R\x0cstartVersion\x12\x14\n\x05limit\x18\x02\
    \x20\x01(\x04R\x05limit\x12!\n\x0cfetch_events\x18\x03\x20\x01(\x08R\x0b\
    fetchEvents\"i\n\x17GetTransactionsResponse\x12N\n\x13txn_list_with_proo\
    f\x18\x01\x20\x01(\x0b2\x1f.types.TransactionListWithProofR\x10txnListWi\
    thProofb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
