// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `vm_errors.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct VMValidationStatus {
    // message fields
    pub code: VMValidationStatusCode,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VMValidationStatus {
    fn default() -> &'a VMValidationStatus {
        <VMValidationStatus as ::protobuf::Message>::default_instance()
    }
}

impl VMValidationStatus {
    pub fn new() -> VMValidationStatus {
        ::std::default::Default::default()
    }

    // .types.VMValidationStatusCode code = 1;


    pub fn get_code(&self) -> VMValidationStatusCode {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = VMValidationStatusCode::UnknownValidationStatus;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: VMValidationStatusCode) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VMValidationStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != VMValidationStatusCode::UnknownValidationStatus {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.code != VMValidationStatusCode::UnknownValidationStatus {
            os.write_enum(1, self.code.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VMValidationStatus {
        VMValidationStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VMValidationStatusCode>>(
                    "code",
                    |m: &VMValidationStatus| { &m.code },
                    |m: &mut VMValidationStatus| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &VMValidationStatus| { &m.message },
                    |m: &mut VMValidationStatus| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VMValidationStatus>(
                    "VMValidationStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VMValidationStatus {
        static mut instance: ::protobuf::lazy::Lazy<VMValidationStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VMValidationStatus,
        };
        unsafe {
            instance.get(VMValidationStatus::new)
        }
    }
}

impl ::protobuf::Clear for VMValidationStatus {
    fn clear(&mut self) {
        self.code = VMValidationStatusCode::UnknownValidationStatus;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VMValidationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VMValidationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VMVerificationStatusList {
    // message fields
    pub status_list: ::protobuf::RepeatedField<VMVerificationStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VMVerificationStatusList {
    fn default() -> &'a VMVerificationStatusList {
        <VMVerificationStatusList as ::protobuf::Message>::default_instance()
    }
}

impl VMVerificationStatusList {
    pub fn new() -> VMVerificationStatusList {
        ::std::default::Default::default()
    }

    // repeated .types.VMVerificationStatus status_list = 1;


    pub fn get_status_list(&self) -> &[VMVerificationStatus] {
        &self.status_list
    }
    pub fn clear_status_list(&mut self) {
        self.status_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_list(&mut self, v: ::protobuf::RepeatedField<VMVerificationStatus>) {
        self.status_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status_list(&mut self) -> &mut ::protobuf::RepeatedField<VMVerificationStatus> {
        &mut self.status_list
    }

    // Take field
    pub fn take_status_list(&mut self) -> ::protobuf::RepeatedField<VMVerificationStatus> {
        ::std::mem::replace(&mut self.status_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VMVerificationStatusList {
    fn is_initialized(&self) -> bool {
        for v in &self.status_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.status_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.status_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.status_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VMVerificationStatusList {
        VMVerificationStatusList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VMVerificationStatus>>(
                    "status_list",
                    |m: &VMVerificationStatusList| { &m.status_list },
                    |m: &mut VMVerificationStatusList| { &mut m.status_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VMVerificationStatusList>(
                    "VMVerificationStatusList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VMVerificationStatusList {
        static mut instance: ::protobuf::lazy::Lazy<VMVerificationStatusList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VMVerificationStatusList,
        };
        unsafe {
            instance.get(VMVerificationStatusList::new)
        }
    }
}

impl ::protobuf::Clear for VMVerificationStatusList {
    fn clear(&mut self) {
        self.status_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VMVerificationStatusList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VMVerificationStatusList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VMVerificationStatus {
    // message fields
    pub status_kind: VMVerificationStatus_StatusKind,
    pub module_idx: u32,
    pub error_kind: VMVerificationErrorKind,
    pub message: ::std::string::String,
    pub dependency_id: ::protobuf::SingularPtrField<super::language_storage::ModuleId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VMVerificationStatus {
    fn default() -> &'a VMVerificationStatus {
        <VMVerificationStatus as ::protobuf::Message>::default_instance()
    }
}

impl VMVerificationStatus {
    pub fn new() -> VMVerificationStatus {
        ::std::default::Default::default()
    }

    // .types.VMVerificationStatus.StatusKind status_kind = 1;


    pub fn get_status_kind(&self) -> VMVerificationStatus_StatusKind {
        self.status_kind
    }
    pub fn clear_status_kind(&mut self) {
        self.status_kind = VMVerificationStatus_StatusKind::SCRIPT;
    }

    // Param is passed by value, moved
    pub fn set_status_kind(&mut self, v: VMVerificationStatus_StatusKind) {
        self.status_kind = v;
    }

    // uint32 module_idx = 2;


    pub fn get_module_idx(&self) -> u32 {
        self.module_idx
    }
    pub fn clear_module_idx(&mut self) {
        self.module_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_module_idx(&mut self, v: u32) {
        self.module_idx = v;
    }

    // .types.VMVerificationErrorKind error_kind = 3;


    pub fn get_error_kind(&self) -> VMVerificationErrorKind {
        self.error_kind
    }
    pub fn clear_error_kind(&mut self) {
        self.error_kind = VMVerificationErrorKind::UnknownVerificationError;
    }

    // Param is passed by value, moved
    pub fn set_error_kind(&mut self, v: VMVerificationErrorKind) {
        self.error_kind = v;
    }

    // string message = 4;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // .types.ModuleId dependency_id = 5;


    pub fn get_dependency_id(&self) -> &super::language_storage::ModuleId {
        self.dependency_id.as_ref().unwrap_or_else(|| super::language_storage::ModuleId::default_instance())
    }
    pub fn clear_dependency_id(&mut self) {
        self.dependency_id.clear();
    }

    pub fn has_dependency_id(&self) -> bool {
        self.dependency_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dependency_id(&mut self, v: super::language_storage::ModuleId) {
        self.dependency_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dependency_id(&mut self) -> &mut super::language_storage::ModuleId {
        if self.dependency_id.is_none() {
            self.dependency_id.set_default();
        }
        self.dependency_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_dependency_id(&mut self) -> super::language_storage::ModuleId {
        self.dependency_id.take().unwrap_or_else(|| super::language_storage::ModuleId::new())
    }
}

impl ::protobuf::Message for VMVerificationStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.dependency_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status_kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.module_idx = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error_kind, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dependency_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status_kind != VMVerificationStatus_StatusKind::SCRIPT {
            my_size += ::protobuf::rt::enum_size(1, self.status_kind);
        }
        if self.module_idx != 0 {
            my_size += ::protobuf::rt::value_size(2, self.module_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.error_kind != VMVerificationErrorKind::UnknownVerificationError {
            my_size += ::protobuf::rt::enum_size(3, self.error_kind);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.message);
        }
        if let Some(ref v) = self.dependency_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status_kind != VMVerificationStatus_StatusKind::SCRIPT {
            os.write_enum(1, self.status_kind.value())?;
        }
        if self.module_idx != 0 {
            os.write_uint32(2, self.module_idx)?;
        }
        if self.error_kind != VMVerificationErrorKind::UnknownVerificationError {
            os.write_enum(3, self.error_kind.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(4, &self.message)?;
        }
        if let Some(ref v) = self.dependency_id.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VMVerificationStatus {
        VMVerificationStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VMVerificationStatus_StatusKind>>(
                    "status_kind",
                    |m: &VMVerificationStatus| { &m.status_kind },
                    |m: &mut VMVerificationStatus| { &mut m.status_kind },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "module_idx",
                    |m: &VMVerificationStatus| { &m.module_idx },
                    |m: &mut VMVerificationStatus| { &mut m.module_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VMVerificationErrorKind>>(
                    "error_kind",
                    |m: &VMVerificationStatus| { &m.error_kind },
                    |m: &mut VMVerificationStatus| { &mut m.error_kind },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &VMVerificationStatus| { &m.message },
                    |m: &mut VMVerificationStatus| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::language_storage::ModuleId>>(
                    "dependency_id",
                    |m: &VMVerificationStatus| { &m.dependency_id },
                    |m: &mut VMVerificationStatus| { &mut m.dependency_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VMVerificationStatus>(
                    "VMVerificationStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VMVerificationStatus {
        static mut instance: ::protobuf::lazy::Lazy<VMVerificationStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VMVerificationStatus,
        };
        unsafe {
            instance.get(VMVerificationStatus::new)
        }
    }
}

impl ::protobuf::Clear for VMVerificationStatus {
    fn clear(&mut self) {
        self.status_kind = VMVerificationStatus_StatusKind::SCRIPT;
        self.module_idx = 0;
        self.error_kind = VMVerificationErrorKind::UnknownVerificationError;
        self.message.clear();
        self.dependency_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VMVerificationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VMVerificationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VMVerificationStatus_StatusKind {
    SCRIPT = 0,
    MODULE = 1,
    DEPENDENCY = 2,
}

impl ::protobuf::ProtobufEnum for VMVerificationStatus_StatusKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VMVerificationStatus_StatusKind> {
        match value {
            0 => ::std::option::Option::Some(VMVerificationStatus_StatusKind::SCRIPT),
            1 => ::std::option::Option::Some(VMVerificationStatus_StatusKind::MODULE),
            2 => ::std::option::Option::Some(VMVerificationStatus_StatusKind::DEPENDENCY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VMVerificationStatus_StatusKind] = &[
            VMVerificationStatus_StatusKind::SCRIPT,
            VMVerificationStatus_StatusKind::MODULE,
            VMVerificationStatus_StatusKind::DEPENDENCY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VMVerificationStatus_StatusKind", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VMVerificationStatus_StatusKind {
}

impl ::std::default::Default for VMVerificationStatus_StatusKind {
    fn default() -> Self {
        VMVerificationStatus_StatusKind::SCRIPT
    }
}

impl ::protobuf::reflect::ProtobufValue for VMVerificationStatus_StatusKind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssertionFailure {
    // message fields
    pub assertion_error_code: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssertionFailure {
    fn default() -> &'a AssertionFailure {
        <AssertionFailure as ::protobuf::Message>::default_instance()
    }
}

impl AssertionFailure {
    pub fn new() -> AssertionFailure {
        ::std::default::Default::default()
    }

    // uint64 assertion_error_code = 1;


    pub fn get_assertion_error_code(&self) -> u64 {
        self.assertion_error_code
    }
    pub fn clear_assertion_error_code(&mut self) {
        self.assertion_error_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_assertion_error_code(&mut self, v: u64) {
        self.assertion_error_code = v;
    }
}

impl ::protobuf::Message for AssertionFailure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.assertion_error_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.assertion_error_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.assertion_error_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.assertion_error_code != 0 {
            os.write_uint64(1, self.assertion_error_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssertionFailure {
        AssertionFailure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "assertion_error_code",
                    |m: &AssertionFailure| { &m.assertion_error_code },
                    |m: &mut AssertionFailure| { &mut m.assertion_error_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssertionFailure>(
                    "AssertionFailure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssertionFailure {
        static mut instance: ::protobuf::lazy::Lazy<AssertionFailure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssertionFailure,
        };
        unsafe {
            instance.get(AssertionFailure::new)
        }
    }
}

impl ::protobuf::Clear for AssertionFailure {
    fn clear(&mut self) {
        self.assertion_error_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssertionFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionFailure {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArithmeticError {
    // message fields
    pub error_code: ArithmeticError_ArithmeticErrorType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArithmeticError {
    fn default() -> &'a ArithmeticError {
        <ArithmeticError as ::protobuf::Message>::default_instance()
    }
}

impl ArithmeticError {
    pub fn new() -> ArithmeticError {
        ::std::default::Default::default()
    }

    // .types.ArithmeticError.ArithmeticErrorType error_code = 1;


    pub fn get_error_code(&self) -> ArithmeticError_ArithmeticErrorType {
        self.error_code
    }
    pub fn clear_error_code(&mut self) {
        self.error_code = ArithmeticError_ArithmeticErrorType::UnknownArithmeticError;
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ArithmeticError_ArithmeticErrorType) {
        self.error_code = v;
    }
}

impl ::protobuf::Message for ArithmeticError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error_code, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error_code != ArithmeticError_ArithmeticErrorType::UnknownArithmeticError {
            my_size += ::protobuf::rt::enum_size(1, self.error_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.error_code != ArithmeticError_ArithmeticErrorType::UnknownArithmeticError {
            os.write_enum(1, self.error_code.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArithmeticError {
        ArithmeticError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ArithmeticError_ArithmeticErrorType>>(
                    "error_code",
                    |m: &ArithmeticError| { &m.error_code },
                    |m: &mut ArithmeticError| { &mut m.error_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ArithmeticError>(
                    "ArithmeticError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ArithmeticError {
        static mut instance: ::protobuf::lazy::Lazy<ArithmeticError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ArithmeticError,
        };
        unsafe {
            instance.get(ArithmeticError::new)
        }
    }
}

impl ::protobuf::Clear for ArithmeticError {
    fn clear(&mut self) {
        self.error_code = ArithmeticError_ArithmeticErrorType::UnknownArithmeticError;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArithmeticError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArithmeticError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ArithmeticError_ArithmeticErrorType {
    UnknownArithmeticError = 0,
    Underflow = 1,
    Overflow = 2,
    DivisionByZero = 3,
}

impl ::protobuf::ProtobufEnum for ArithmeticError_ArithmeticErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ArithmeticError_ArithmeticErrorType> {
        match value {
            0 => ::std::option::Option::Some(ArithmeticError_ArithmeticErrorType::UnknownArithmeticError),
            1 => ::std::option::Option::Some(ArithmeticError_ArithmeticErrorType::Underflow),
            2 => ::std::option::Option::Some(ArithmeticError_ArithmeticErrorType::Overflow),
            3 => ::std::option::Option::Some(ArithmeticError_ArithmeticErrorType::DivisionByZero),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ArithmeticError_ArithmeticErrorType] = &[
            ArithmeticError_ArithmeticErrorType::UnknownArithmeticError,
            ArithmeticError_ArithmeticErrorType::Underflow,
            ArithmeticError_ArithmeticErrorType::Overflow,
            ArithmeticError_ArithmeticErrorType::DivisionByZero,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ArithmeticError_ArithmeticErrorType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ArithmeticError_ArithmeticErrorType {
}

impl ::std::default::Default for ArithmeticError_ArithmeticErrorType {
    fn default() -> Self {
        ArithmeticError_ArithmeticErrorType::UnknownArithmeticError
    }
}

impl ::protobuf::reflect::ProtobufValue for ArithmeticError_ArithmeticErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DynamicReferenceError {
    // message fields
    pub error_code: DynamicReferenceError_DynamicReferenceErrorType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DynamicReferenceError {
    fn default() -> &'a DynamicReferenceError {
        <DynamicReferenceError as ::protobuf::Message>::default_instance()
    }
}

impl DynamicReferenceError {
    pub fn new() -> DynamicReferenceError {
        ::std::default::Default::default()
    }

    // .types.DynamicReferenceError.DynamicReferenceErrorType error_code = 1;


    pub fn get_error_code(&self) -> DynamicReferenceError_DynamicReferenceErrorType {
        self.error_code
    }
    pub fn clear_error_code(&mut self) {
        self.error_code = DynamicReferenceError_DynamicReferenceErrorType::UnknownDynamicReferenceError;
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: DynamicReferenceError_DynamicReferenceErrorType) {
        self.error_code = v;
    }
}

impl ::protobuf::Message for DynamicReferenceError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error_code, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error_code != DynamicReferenceError_DynamicReferenceErrorType::UnknownDynamicReferenceError {
            my_size += ::protobuf::rt::enum_size(1, self.error_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.error_code != DynamicReferenceError_DynamicReferenceErrorType::UnknownDynamicReferenceError {
            os.write_enum(1, self.error_code.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DynamicReferenceError {
        DynamicReferenceError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DynamicReferenceError_DynamicReferenceErrorType>>(
                    "error_code",
                    |m: &DynamicReferenceError| { &m.error_code },
                    |m: &mut DynamicReferenceError| { &mut m.error_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DynamicReferenceError>(
                    "DynamicReferenceError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DynamicReferenceError {
        static mut instance: ::protobuf::lazy::Lazy<DynamicReferenceError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DynamicReferenceError,
        };
        unsafe {
            instance.get(DynamicReferenceError::new)
        }
    }
}

impl ::protobuf::Clear for DynamicReferenceError {
    fn clear(&mut self) {
        self.error_code = DynamicReferenceError_DynamicReferenceErrorType::UnknownDynamicReferenceError;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DynamicReferenceError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicReferenceError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DynamicReferenceError_DynamicReferenceErrorType {
    UnknownDynamicReferenceError = 0,
    MoveOfBorrowedResource = 1,
    GlobalRefAlreadyReleased = 2,
    MissingReleaseRef = 3,
    GlobalAlreadyBorrowed = 4,
}

impl ::protobuf::ProtobufEnum for DynamicReferenceError_DynamicReferenceErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DynamicReferenceError_DynamicReferenceErrorType> {
        match value {
            0 => ::std::option::Option::Some(DynamicReferenceError_DynamicReferenceErrorType::UnknownDynamicReferenceError),
            1 => ::std::option::Option::Some(DynamicReferenceError_DynamicReferenceErrorType::MoveOfBorrowedResource),
            2 => ::std::option::Option::Some(DynamicReferenceError_DynamicReferenceErrorType::GlobalRefAlreadyReleased),
            3 => ::std::option::Option::Some(DynamicReferenceError_DynamicReferenceErrorType::MissingReleaseRef),
            4 => ::std::option::Option::Some(DynamicReferenceError_DynamicReferenceErrorType::GlobalAlreadyBorrowed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DynamicReferenceError_DynamicReferenceErrorType] = &[
            DynamicReferenceError_DynamicReferenceErrorType::UnknownDynamicReferenceError,
            DynamicReferenceError_DynamicReferenceErrorType::MoveOfBorrowedResource,
            DynamicReferenceError_DynamicReferenceErrorType::GlobalRefAlreadyReleased,
            DynamicReferenceError_DynamicReferenceErrorType::MissingReleaseRef,
            DynamicReferenceError_DynamicReferenceErrorType::GlobalAlreadyBorrowed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DynamicReferenceError_DynamicReferenceErrorType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DynamicReferenceError_DynamicReferenceErrorType {
}

impl ::std::default::Default for DynamicReferenceError_DynamicReferenceErrorType {
    fn default() -> Self {
        DynamicReferenceError_DynamicReferenceErrorType::UnknownDynamicReferenceError
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicReferenceError_DynamicReferenceErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutionStatus {
    // message oneof groups
    pub execution_status: ::std::option::Option<ExecutionStatus_oneof_execution_status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionStatus {
    fn default() -> &'a ExecutionStatus {
        <ExecutionStatus as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExecutionStatus_oneof_execution_status {
    runtime_status(RuntimeStatus),
    assertion_failure(AssertionFailure),
    arithmetic_error(ArithmeticError),
    reference_error(DynamicReferenceError),
}

impl ExecutionStatus {
    pub fn new() -> ExecutionStatus {
        ::std::default::Default::default()
    }

    // .types.RuntimeStatus runtime_status = 1;


    pub fn get_runtime_status(&self) -> RuntimeStatus {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::runtime_status(v)) => v,
            _ => RuntimeStatus::UnknownRuntimeStatus,
        }
    }
    pub fn clear_runtime_status(&mut self) {
        self.execution_status = ::std::option::Option::None;
    }

    pub fn has_runtime_status(&self) -> bool {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::runtime_status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runtime_status(&mut self, v: RuntimeStatus) {
        self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::runtime_status(v))
    }

    // .types.AssertionFailure assertion_failure = 2;


    pub fn get_assertion_failure(&self) -> &AssertionFailure {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(ref v)) => v,
            _ => AssertionFailure::default_instance(),
        }
    }
    pub fn clear_assertion_failure(&mut self) {
        self.execution_status = ::std::option::Option::None;
    }

    pub fn has_assertion_failure(&self) -> bool {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_assertion_failure(&mut self, v: AssertionFailure) {
        self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(v))
    }

    // Mutable pointer to the field.
    pub fn mut_assertion_failure(&mut self) -> &mut AssertionFailure {
        if let ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(_)) = self.execution_status {
        } else {
            self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(AssertionFailure::new()));
        }
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_assertion_failure(&mut self) -> AssertionFailure {
        if self.has_assertion_failure() {
            match self.execution_status.take() {
                ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(v)) => v,
                _ => panic!(),
            }
        } else {
            AssertionFailure::new()
        }
    }

    // .types.ArithmeticError arithmetic_error = 3;


    pub fn get_arithmetic_error(&self) -> &ArithmeticError {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(ref v)) => v,
            _ => ArithmeticError::default_instance(),
        }
    }
    pub fn clear_arithmetic_error(&mut self) {
        self.execution_status = ::std::option::Option::None;
    }

    pub fn has_arithmetic_error(&self) -> bool {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arithmetic_error(&mut self, v: ArithmeticError) {
        self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_arithmetic_error(&mut self) -> &mut ArithmeticError {
        if let ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(_)) = self.execution_status {
        } else {
            self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(ArithmeticError::new()));
        }
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arithmetic_error(&mut self) -> ArithmeticError {
        if self.has_arithmetic_error() {
            match self.execution_status.take() {
                ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(v)) => v,
                _ => panic!(),
            }
        } else {
            ArithmeticError::new()
        }
    }

    // .types.DynamicReferenceError reference_error = 4;


    pub fn get_reference_error(&self) -> &DynamicReferenceError {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(ref v)) => v,
            _ => DynamicReferenceError::default_instance(),
        }
    }
    pub fn clear_reference_error(&mut self) {
        self.execution_status = ::std::option::Option::None;
    }

    pub fn has_reference_error(&self) -> bool {
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference_error(&mut self, v: DynamicReferenceError) {
        self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference_error(&mut self) -> &mut DynamicReferenceError {
        if let ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(_)) = self.execution_status {
        } else {
            self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(DynamicReferenceError::new()));
        }
        match self.execution_status {
            ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference_error(&mut self) -> DynamicReferenceError {
        if self.has_reference_error() {
            match self.execution_status.take() {
                ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(v)) => v,
                _ => panic!(),
            }
        } else {
            DynamicReferenceError::new()
        }
    }
}

impl ::protobuf::Message for ExecutionStatus {
    fn is_initialized(&self) -> bool {
        if let Some(ExecutionStatus_oneof_execution_status::assertion_failure(ref v)) = self.execution_status {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExecutionStatus_oneof_execution_status::arithmetic_error(ref v)) = self.execution_status {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExecutionStatus_oneof_execution_status::reference_error(ref v)) = self.execution_status {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::runtime_status(is.read_enum()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::assertion_failure(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::arithmetic_error(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.execution_status = ::std::option::Option::Some(ExecutionStatus_oneof_execution_status::reference_error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.execution_status {
            match v {
                &ExecutionStatus_oneof_execution_status::runtime_status(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
                &ExecutionStatus_oneof_execution_status::assertion_failure(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExecutionStatus_oneof_execution_status::arithmetic_error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExecutionStatus_oneof_execution_status::reference_error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.execution_status {
            match v {
                &ExecutionStatus_oneof_execution_status::runtime_status(v) => {
                    os.write_enum(1, v.value())?;
                },
                &ExecutionStatus_oneof_execution_status::assertion_failure(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExecutionStatus_oneof_execution_status::arithmetic_error(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExecutionStatus_oneof_execution_status::reference_error(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutionStatus {
        ExecutionStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, RuntimeStatus>(
                    "runtime_status",
                    ExecutionStatus::has_runtime_status,
                    ExecutionStatus::get_runtime_status,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AssertionFailure>(
                    "assertion_failure",
                    ExecutionStatus::has_assertion_failure,
                    ExecutionStatus::get_assertion_failure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ArithmeticError>(
                    "arithmetic_error",
                    ExecutionStatus::has_arithmetic_error,
                    ExecutionStatus::get_arithmetic_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DynamicReferenceError>(
                    "reference_error",
                    ExecutionStatus::has_reference_error,
                    ExecutionStatus::get_reference_error,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutionStatus>(
                    "ExecutionStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecutionStatus {
        static mut instance: ::protobuf::lazy::Lazy<ExecutionStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutionStatus,
        };
        unsafe {
            instance.get(ExecutionStatus::new)
        }
    }
}

impl ::protobuf::Clear for ExecutionStatus {
    fn clear(&mut self) {
        self.execution_status = ::std::option::Option::None;
        self.execution_status = ::std::option::Option::None;
        self.execution_status = ::std::option::Option::None;
        self.execution_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VMStatus {
    // message oneof groups
    pub error_type: ::std::option::Option<VMStatus_oneof_error_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VMStatus {
    fn default() -> &'a VMStatus {
        <VMStatus as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum VMStatus_oneof_error_type {
    validation(VMValidationStatus),
    verification(VMVerificationStatusList),
    invariant_violation(VMInvariantViolationError),
    deserialization(BinaryError),
    execution(ExecutionStatus),
}

impl VMStatus {
    pub fn new() -> VMStatus {
        ::std::default::Default::default()
    }

    // .types.VMValidationStatus validation = 1;


    pub fn get_validation(&self) -> &VMValidationStatus {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::validation(ref v)) => v,
            _ => VMValidationStatus::default_instance(),
        }
    }
    pub fn clear_validation(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_validation(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::validation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_validation(&mut self, v: VMValidationStatus) {
        self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::validation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_validation(&mut self) -> &mut VMValidationStatus {
        if let ::std::option::Option::Some(VMStatus_oneof_error_type::validation(_)) = self.error_type {
        } else {
            self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::validation(VMValidationStatus::new()));
        }
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::validation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_validation(&mut self) -> VMValidationStatus {
        if self.has_validation() {
            match self.error_type.take() {
                ::std::option::Option::Some(VMStatus_oneof_error_type::validation(v)) => v,
                _ => panic!(),
            }
        } else {
            VMValidationStatus::new()
        }
    }

    // .types.VMVerificationStatusList verification = 2;


    pub fn get_verification(&self) -> &VMVerificationStatusList {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::verification(ref v)) => v,
            _ => VMVerificationStatusList::default_instance(),
        }
    }
    pub fn clear_verification(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_verification(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::verification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_verification(&mut self, v: VMVerificationStatusList) {
        self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::verification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_verification(&mut self) -> &mut VMVerificationStatusList {
        if let ::std::option::Option::Some(VMStatus_oneof_error_type::verification(_)) = self.error_type {
        } else {
            self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::verification(VMVerificationStatusList::new()));
        }
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::verification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_verification(&mut self) -> VMVerificationStatusList {
        if self.has_verification() {
            match self.error_type.take() {
                ::std::option::Option::Some(VMStatus_oneof_error_type::verification(v)) => v,
                _ => panic!(),
            }
        } else {
            VMVerificationStatusList::new()
        }
    }

    // .types.VMInvariantViolationError invariant_violation = 3;


    pub fn get_invariant_violation(&self) -> VMInvariantViolationError {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::invariant_violation(v)) => v,
            _ => VMInvariantViolationError::UnknownInvariantViolationError,
        }
    }
    pub fn clear_invariant_violation(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_invariant_violation(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::invariant_violation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_invariant_violation(&mut self, v: VMInvariantViolationError) {
        self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::invariant_violation(v))
    }

    // .types.BinaryError deserialization = 4;


    pub fn get_deserialization(&self) -> BinaryError {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::deserialization(v)) => v,
            _ => BinaryError::UnknownBinaryError,
        }
    }
    pub fn clear_deserialization(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_deserialization(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::deserialization(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deserialization(&mut self, v: BinaryError) {
        self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::deserialization(v))
    }

    // .types.ExecutionStatus execution = 5;


    pub fn get_execution(&self) -> &ExecutionStatus {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::execution(ref v)) => v,
            _ => ExecutionStatus::default_instance(),
        }
    }
    pub fn clear_execution(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_execution(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::execution(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_execution(&mut self, v: ExecutionStatus) {
        self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::execution(v))
    }

    // Mutable pointer to the field.
    pub fn mut_execution(&mut self) -> &mut ExecutionStatus {
        if let ::std::option::Option::Some(VMStatus_oneof_error_type::execution(_)) = self.error_type {
        } else {
            self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::execution(ExecutionStatus::new()));
        }
        match self.error_type {
            ::std::option::Option::Some(VMStatus_oneof_error_type::execution(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_execution(&mut self) -> ExecutionStatus {
        if self.has_execution() {
            match self.error_type.take() {
                ::std::option::Option::Some(VMStatus_oneof_error_type::execution(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecutionStatus::new()
        }
    }
}

impl ::protobuf::Message for VMStatus {
    fn is_initialized(&self) -> bool {
        if let Some(VMStatus_oneof_error_type::validation(ref v)) = self.error_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VMStatus_oneof_error_type::verification(ref v)) = self.error_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VMStatus_oneof_error_type::execution(ref v)) = self.error_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::validation(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::verification(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::invariant_violation(is.read_enum()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::deserialization(is.read_enum()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(VMStatus_oneof_error_type::execution(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.error_type {
            match v {
                &VMStatus_oneof_error_type::validation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VMStatus_oneof_error_type::verification(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VMStatus_oneof_error_type::invariant_violation(v) => {
                    my_size += ::protobuf::rt::enum_size(3, v);
                },
                &VMStatus_oneof_error_type::deserialization(v) => {
                    my_size += ::protobuf::rt::enum_size(4, v);
                },
                &VMStatus_oneof_error_type::execution(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.error_type {
            match v {
                &VMStatus_oneof_error_type::validation(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VMStatus_oneof_error_type::verification(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VMStatus_oneof_error_type::invariant_violation(v) => {
                    os.write_enum(3, v.value())?;
                },
                &VMStatus_oneof_error_type::deserialization(v) => {
                    os.write_enum(4, v.value())?;
                },
                &VMStatus_oneof_error_type::execution(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VMStatus {
        VMStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VMValidationStatus>(
                    "validation",
                    VMStatus::has_validation,
                    VMStatus::get_validation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VMVerificationStatusList>(
                    "verification",
                    VMStatus::has_verification,
                    VMStatus::get_verification,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, VMInvariantViolationError>(
                    "invariant_violation",
                    VMStatus::has_invariant_violation,
                    VMStatus::get_invariant_violation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, BinaryError>(
                    "deserialization",
                    VMStatus::has_deserialization,
                    VMStatus::get_deserialization,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecutionStatus>(
                    "execution",
                    VMStatus::has_execution,
                    VMStatus::get_execution,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VMStatus>(
                    "VMStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VMStatus {
        static mut instance: ::protobuf::lazy::Lazy<VMStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VMStatus,
        };
        unsafe {
            instance.get(VMStatus::new)
        }
    }
}

impl ::protobuf::Clear for VMStatus {
    fn clear(&mut self) {
        self.error_type = ::std::option::Option::None;
        self.error_type = ::std::option::Option::None;
        self.error_type = ::std::option::Option::None;
        self.error_type = ::std::option::Option::None;
        self.error_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VMStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VMStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VMValidationStatusCode {
    UnknownValidationStatus = 0,
    InvalidSignature = 1,
    InvalidAuthKey = 2,
    SequenceNumberTooOld = 3,
    SequenceNumberTooNew = 4,
    InsufficientBalanceForTransactionFee = 5,
    TransactionExpired = 6,
    SendingAccountDoesNotExist = 7,
    RejectedWriteSet = 8,
    InvalidWriteSet = 9,
    ExceededMaxTransactionSize = 10,
    UnknownScript = 11,
    UnknownModule = 12,
    MaxGasUnitsExceedsMaxGasUnitsBound = 13,
    MaxGasUnitsBelowMinTransactionGasUnits = 14,
    GasUnitPriceBelowMinBound = 15,
    GasUnitPriceAboveMaxBound = 16,
}

impl ::protobuf::ProtobufEnum for VMValidationStatusCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VMValidationStatusCode> {
        match value {
            0 => ::std::option::Option::Some(VMValidationStatusCode::UnknownValidationStatus),
            1 => ::std::option::Option::Some(VMValidationStatusCode::InvalidSignature),
            2 => ::std::option::Option::Some(VMValidationStatusCode::InvalidAuthKey),
            3 => ::std::option::Option::Some(VMValidationStatusCode::SequenceNumberTooOld),
            4 => ::std::option::Option::Some(VMValidationStatusCode::SequenceNumberTooNew),
            5 => ::std::option::Option::Some(VMValidationStatusCode::InsufficientBalanceForTransactionFee),
            6 => ::std::option::Option::Some(VMValidationStatusCode::TransactionExpired),
            7 => ::std::option::Option::Some(VMValidationStatusCode::SendingAccountDoesNotExist),
            8 => ::std::option::Option::Some(VMValidationStatusCode::RejectedWriteSet),
            9 => ::std::option::Option::Some(VMValidationStatusCode::InvalidWriteSet),
            10 => ::std::option::Option::Some(VMValidationStatusCode::ExceededMaxTransactionSize),
            11 => ::std::option::Option::Some(VMValidationStatusCode::UnknownScript),
            12 => ::std::option::Option::Some(VMValidationStatusCode::UnknownModule),
            13 => ::std::option::Option::Some(VMValidationStatusCode::MaxGasUnitsExceedsMaxGasUnitsBound),
            14 => ::std::option::Option::Some(VMValidationStatusCode::MaxGasUnitsBelowMinTransactionGasUnits),
            15 => ::std::option::Option::Some(VMValidationStatusCode::GasUnitPriceBelowMinBound),
            16 => ::std::option::Option::Some(VMValidationStatusCode::GasUnitPriceAboveMaxBound),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VMValidationStatusCode] = &[
            VMValidationStatusCode::UnknownValidationStatus,
            VMValidationStatusCode::InvalidSignature,
            VMValidationStatusCode::InvalidAuthKey,
            VMValidationStatusCode::SequenceNumberTooOld,
            VMValidationStatusCode::SequenceNumberTooNew,
            VMValidationStatusCode::InsufficientBalanceForTransactionFee,
            VMValidationStatusCode::TransactionExpired,
            VMValidationStatusCode::SendingAccountDoesNotExist,
            VMValidationStatusCode::RejectedWriteSet,
            VMValidationStatusCode::InvalidWriteSet,
            VMValidationStatusCode::ExceededMaxTransactionSize,
            VMValidationStatusCode::UnknownScript,
            VMValidationStatusCode::UnknownModule,
            VMValidationStatusCode::MaxGasUnitsExceedsMaxGasUnitsBound,
            VMValidationStatusCode::MaxGasUnitsBelowMinTransactionGasUnits,
            VMValidationStatusCode::GasUnitPriceBelowMinBound,
            VMValidationStatusCode::GasUnitPriceAboveMaxBound,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VMValidationStatusCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VMValidationStatusCode {
}

impl ::std::default::Default for VMValidationStatusCode {
    fn default() -> Self {
        VMValidationStatusCode::UnknownValidationStatus
    }
}

impl ::protobuf::reflect::ProtobufValue for VMValidationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VMVerificationErrorKind {
    UnknownVerificationError = 0,
    IndexOutOfBounds = 1,
    RangeOutOfBounds = 2,
    InvalidSignatureToken = 3,
    InvalidFieldDefReference = 4,
    RecursiveStructDefinition = 5,
    InvalidResourceField = 6,
    InvalidFallThrough = 7,
    JoinFailure = 8,
    NegativeStackSizeWithinBlock = 9,
    UnbalancedStack = 10,
    InvalidMainFunctionSignature = 11,
    DuplicateElement = 12,
    InvalidModuleHandle = 13,
    UnimplementedHandle = 14,
    InconsistentFields = 15,
    UnusedFields = 16,
    LookupFailed = 17,
    VisibilityMismatch = 18,
    TypeResolutionFailure = 19,
    TypeMismatch = 20,
    MissingDependency = 21,
    PopReferenceError = 22,
    PopResourceError = 23,
    ReleaseRefTypeMismatchError = 24,
    BrTypeMismatchError = 25,
    AssertTypeMismatchError = 26,
    StLocTypeMismatchError = 27,
    StLocUnsafeToDestroyError = 28,
    RetUnsafeToDestroyError = 29,
    RetTypeMismatchError = 30,
    FreezeRefTypeMismatchError = 31,
    FreezeRefExistsMutableBorrowError = 32,
    BorrowFieldTypeMismatchError = 33,
    BorrowFieldBadFieldError = 34,
    BorrowFieldExistsMutableBorrowError = 35,
    CopyLocUnavailableError = 36,
    CopyLocResourceError = 37,
    CopyLocExistsBorrowError = 38,
    MoveLocUnavailableError = 39,
    MoveLocExistsBorrowError = 40,
    BorrowLocReferenceError = 41,
    BorrowLocUnavailableError = 42,
    BorrowLocExistsBorrowError = 43,
    CallTypeMismatchError = 44,
    CallBorrowedMutableReferenceError = 45,
    PackTypeMismatchError = 46,
    UnpackTypeMismatchError = 47,
    ReadRefTypeMismatchError = 48,
    ReadRefResourceError = 49,
    ReadRefExistsMutableBorrowError = 50,
    WriteRefTypeMismatchError = 51,
    WriteRefResourceError = 52,
    WriteRefExistsBorrowError = 53,
    WriteRefNoMutableReferenceError = 54,
    IntegerOpTypeMismatchError = 55,
    BooleanOpTypeMismatchError = 56,
    EqualityOpTypeMismatchError = 57,
    ExistsResourceTypeMismatchError = 58,
    BorrowGlobalTypeMismatchError = 59,
    BorrowGlobalNoResourceError = 60,
    MoveFromTypeMismatchError = 61,
    MoveFromNoResourceError = 62,
    MoveToSenderTypeMismatchError = 63,
    MoveToSenderNoResourceError = 64,
    CreateAccountTypeMismatchError = 65,
    ModuleAddressDoesNotMatchSender = 66,
    NoModuleHandles = 67,
}

impl ::protobuf::ProtobufEnum for VMVerificationErrorKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VMVerificationErrorKind> {
        match value {
            0 => ::std::option::Option::Some(VMVerificationErrorKind::UnknownVerificationError),
            1 => ::std::option::Option::Some(VMVerificationErrorKind::IndexOutOfBounds),
            2 => ::std::option::Option::Some(VMVerificationErrorKind::RangeOutOfBounds),
            3 => ::std::option::Option::Some(VMVerificationErrorKind::InvalidSignatureToken),
            4 => ::std::option::Option::Some(VMVerificationErrorKind::InvalidFieldDefReference),
            5 => ::std::option::Option::Some(VMVerificationErrorKind::RecursiveStructDefinition),
            6 => ::std::option::Option::Some(VMVerificationErrorKind::InvalidResourceField),
            7 => ::std::option::Option::Some(VMVerificationErrorKind::InvalidFallThrough),
            8 => ::std::option::Option::Some(VMVerificationErrorKind::JoinFailure),
            9 => ::std::option::Option::Some(VMVerificationErrorKind::NegativeStackSizeWithinBlock),
            10 => ::std::option::Option::Some(VMVerificationErrorKind::UnbalancedStack),
            11 => ::std::option::Option::Some(VMVerificationErrorKind::InvalidMainFunctionSignature),
            12 => ::std::option::Option::Some(VMVerificationErrorKind::DuplicateElement),
            13 => ::std::option::Option::Some(VMVerificationErrorKind::InvalidModuleHandle),
            14 => ::std::option::Option::Some(VMVerificationErrorKind::UnimplementedHandle),
            15 => ::std::option::Option::Some(VMVerificationErrorKind::InconsistentFields),
            16 => ::std::option::Option::Some(VMVerificationErrorKind::UnusedFields),
            17 => ::std::option::Option::Some(VMVerificationErrorKind::LookupFailed),
            18 => ::std::option::Option::Some(VMVerificationErrorKind::VisibilityMismatch),
            19 => ::std::option::Option::Some(VMVerificationErrorKind::TypeResolutionFailure),
            20 => ::std::option::Option::Some(VMVerificationErrorKind::TypeMismatch),
            21 => ::std::option::Option::Some(VMVerificationErrorKind::MissingDependency),
            22 => ::std::option::Option::Some(VMVerificationErrorKind::PopReferenceError),
            23 => ::std::option::Option::Some(VMVerificationErrorKind::PopResourceError),
            24 => ::std::option::Option::Some(VMVerificationErrorKind::ReleaseRefTypeMismatchError),
            25 => ::std::option::Option::Some(VMVerificationErrorKind::BrTypeMismatchError),
            26 => ::std::option::Option::Some(VMVerificationErrorKind::AssertTypeMismatchError),
            27 => ::std::option::Option::Some(VMVerificationErrorKind::StLocTypeMismatchError),
            28 => ::std::option::Option::Some(VMVerificationErrorKind::StLocUnsafeToDestroyError),
            29 => ::std::option::Option::Some(VMVerificationErrorKind::RetUnsafeToDestroyError),
            30 => ::std::option::Option::Some(VMVerificationErrorKind::RetTypeMismatchError),
            31 => ::std::option::Option::Some(VMVerificationErrorKind::FreezeRefTypeMismatchError),
            32 => ::std::option::Option::Some(VMVerificationErrorKind::FreezeRefExistsMutableBorrowError),
            33 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowFieldTypeMismatchError),
            34 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowFieldBadFieldError),
            35 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowFieldExistsMutableBorrowError),
            36 => ::std::option::Option::Some(VMVerificationErrorKind::CopyLocUnavailableError),
            37 => ::std::option::Option::Some(VMVerificationErrorKind::CopyLocResourceError),
            38 => ::std::option::Option::Some(VMVerificationErrorKind::CopyLocExistsBorrowError),
            39 => ::std::option::Option::Some(VMVerificationErrorKind::MoveLocUnavailableError),
            40 => ::std::option::Option::Some(VMVerificationErrorKind::MoveLocExistsBorrowError),
            41 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowLocReferenceError),
            42 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowLocUnavailableError),
            43 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowLocExistsBorrowError),
            44 => ::std::option::Option::Some(VMVerificationErrorKind::CallTypeMismatchError),
            45 => ::std::option::Option::Some(VMVerificationErrorKind::CallBorrowedMutableReferenceError),
            46 => ::std::option::Option::Some(VMVerificationErrorKind::PackTypeMismatchError),
            47 => ::std::option::Option::Some(VMVerificationErrorKind::UnpackTypeMismatchError),
            48 => ::std::option::Option::Some(VMVerificationErrorKind::ReadRefTypeMismatchError),
            49 => ::std::option::Option::Some(VMVerificationErrorKind::ReadRefResourceError),
            50 => ::std::option::Option::Some(VMVerificationErrorKind::ReadRefExistsMutableBorrowError),
            51 => ::std::option::Option::Some(VMVerificationErrorKind::WriteRefTypeMismatchError),
            52 => ::std::option::Option::Some(VMVerificationErrorKind::WriteRefResourceError),
            53 => ::std::option::Option::Some(VMVerificationErrorKind::WriteRefExistsBorrowError),
            54 => ::std::option::Option::Some(VMVerificationErrorKind::WriteRefNoMutableReferenceError),
            55 => ::std::option::Option::Some(VMVerificationErrorKind::IntegerOpTypeMismatchError),
            56 => ::std::option::Option::Some(VMVerificationErrorKind::BooleanOpTypeMismatchError),
            57 => ::std::option::Option::Some(VMVerificationErrorKind::EqualityOpTypeMismatchError),
            58 => ::std::option::Option::Some(VMVerificationErrorKind::ExistsResourceTypeMismatchError),
            59 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowGlobalTypeMismatchError),
            60 => ::std::option::Option::Some(VMVerificationErrorKind::BorrowGlobalNoResourceError),
            61 => ::std::option::Option::Some(VMVerificationErrorKind::MoveFromTypeMismatchError),
            62 => ::std::option::Option::Some(VMVerificationErrorKind::MoveFromNoResourceError),
            63 => ::std::option::Option::Some(VMVerificationErrorKind::MoveToSenderTypeMismatchError),
            64 => ::std::option::Option::Some(VMVerificationErrorKind::MoveToSenderNoResourceError),
            65 => ::std::option::Option::Some(VMVerificationErrorKind::CreateAccountTypeMismatchError),
            66 => ::std::option::Option::Some(VMVerificationErrorKind::ModuleAddressDoesNotMatchSender),
            67 => ::std::option::Option::Some(VMVerificationErrorKind::NoModuleHandles),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VMVerificationErrorKind] = &[
            VMVerificationErrorKind::UnknownVerificationError,
            VMVerificationErrorKind::IndexOutOfBounds,
            VMVerificationErrorKind::RangeOutOfBounds,
            VMVerificationErrorKind::InvalidSignatureToken,
            VMVerificationErrorKind::InvalidFieldDefReference,
            VMVerificationErrorKind::RecursiveStructDefinition,
            VMVerificationErrorKind::InvalidResourceField,
            VMVerificationErrorKind::InvalidFallThrough,
            VMVerificationErrorKind::JoinFailure,
            VMVerificationErrorKind::NegativeStackSizeWithinBlock,
            VMVerificationErrorKind::UnbalancedStack,
            VMVerificationErrorKind::InvalidMainFunctionSignature,
            VMVerificationErrorKind::DuplicateElement,
            VMVerificationErrorKind::InvalidModuleHandle,
            VMVerificationErrorKind::UnimplementedHandle,
            VMVerificationErrorKind::InconsistentFields,
            VMVerificationErrorKind::UnusedFields,
            VMVerificationErrorKind::LookupFailed,
            VMVerificationErrorKind::VisibilityMismatch,
            VMVerificationErrorKind::TypeResolutionFailure,
            VMVerificationErrorKind::TypeMismatch,
            VMVerificationErrorKind::MissingDependency,
            VMVerificationErrorKind::PopReferenceError,
            VMVerificationErrorKind::PopResourceError,
            VMVerificationErrorKind::ReleaseRefTypeMismatchError,
            VMVerificationErrorKind::BrTypeMismatchError,
            VMVerificationErrorKind::AssertTypeMismatchError,
            VMVerificationErrorKind::StLocTypeMismatchError,
            VMVerificationErrorKind::StLocUnsafeToDestroyError,
            VMVerificationErrorKind::RetUnsafeToDestroyError,
            VMVerificationErrorKind::RetTypeMismatchError,
            VMVerificationErrorKind::FreezeRefTypeMismatchError,
            VMVerificationErrorKind::FreezeRefExistsMutableBorrowError,
            VMVerificationErrorKind::BorrowFieldTypeMismatchError,
            VMVerificationErrorKind::BorrowFieldBadFieldError,
            VMVerificationErrorKind::BorrowFieldExistsMutableBorrowError,
            VMVerificationErrorKind::CopyLocUnavailableError,
            VMVerificationErrorKind::CopyLocResourceError,
            VMVerificationErrorKind::CopyLocExistsBorrowError,
            VMVerificationErrorKind::MoveLocUnavailableError,
            VMVerificationErrorKind::MoveLocExistsBorrowError,
            VMVerificationErrorKind::BorrowLocReferenceError,
            VMVerificationErrorKind::BorrowLocUnavailableError,
            VMVerificationErrorKind::BorrowLocExistsBorrowError,
            VMVerificationErrorKind::CallTypeMismatchError,
            VMVerificationErrorKind::CallBorrowedMutableReferenceError,
            VMVerificationErrorKind::PackTypeMismatchError,
            VMVerificationErrorKind::UnpackTypeMismatchError,
            VMVerificationErrorKind::ReadRefTypeMismatchError,
            VMVerificationErrorKind::ReadRefResourceError,
            VMVerificationErrorKind::ReadRefExistsMutableBorrowError,
            VMVerificationErrorKind::WriteRefTypeMismatchError,
            VMVerificationErrorKind::WriteRefResourceError,
            VMVerificationErrorKind::WriteRefExistsBorrowError,
            VMVerificationErrorKind::WriteRefNoMutableReferenceError,
            VMVerificationErrorKind::IntegerOpTypeMismatchError,
            VMVerificationErrorKind::BooleanOpTypeMismatchError,
            VMVerificationErrorKind::EqualityOpTypeMismatchError,
            VMVerificationErrorKind::ExistsResourceTypeMismatchError,
            VMVerificationErrorKind::BorrowGlobalTypeMismatchError,
            VMVerificationErrorKind::BorrowGlobalNoResourceError,
            VMVerificationErrorKind::MoveFromTypeMismatchError,
            VMVerificationErrorKind::MoveFromNoResourceError,
            VMVerificationErrorKind::MoveToSenderTypeMismatchError,
            VMVerificationErrorKind::MoveToSenderNoResourceError,
            VMVerificationErrorKind::CreateAccountTypeMismatchError,
            VMVerificationErrorKind::ModuleAddressDoesNotMatchSender,
            VMVerificationErrorKind::NoModuleHandles,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VMVerificationErrorKind", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VMVerificationErrorKind {
}

impl ::std::default::Default for VMVerificationErrorKind {
    fn default() -> Self {
        VMVerificationErrorKind::UnknownVerificationError
    }
}

impl ::protobuf::reflect::ProtobufValue for VMVerificationErrorKind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VMInvariantViolationError {
    UnknownInvariantViolationError = 0,
    OutOfBoundsIndex = 1,
    OutOfBoundsRange = 2,
    EmptyValueStack = 3,
    EmptyCallStack = 4,
    PCOverflow = 5,
    LinkerError = 6,
    LocalReferenceError = 7,
    StorageError = 8,
}

impl ::protobuf::ProtobufEnum for VMInvariantViolationError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VMInvariantViolationError> {
        match value {
            0 => ::std::option::Option::Some(VMInvariantViolationError::UnknownInvariantViolationError),
            1 => ::std::option::Option::Some(VMInvariantViolationError::OutOfBoundsIndex),
            2 => ::std::option::Option::Some(VMInvariantViolationError::OutOfBoundsRange),
            3 => ::std::option::Option::Some(VMInvariantViolationError::EmptyValueStack),
            4 => ::std::option::Option::Some(VMInvariantViolationError::EmptyCallStack),
            5 => ::std::option::Option::Some(VMInvariantViolationError::PCOverflow),
            6 => ::std::option::Option::Some(VMInvariantViolationError::LinkerError),
            7 => ::std::option::Option::Some(VMInvariantViolationError::LocalReferenceError),
            8 => ::std::option::Option::Some(VMInvariantViolationError::StorageError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VMInvariantViolationError] = &[
            VMInvariantViolationError::UnknownInvariantViolationError,
            VMInvariantViolationError::OutOfBoundsIndex,
            VMInvariantViolationError::OutOfBoundsRange,
            VMInvariantViolationError::EmptyValueStack,
            VMInvariantViolationError::EmptyCallStack,
            VMInvariantViolationError::PCOverflow,
            VMInvariantViolationError::LinkerError,
            VMInvariantViolationError::LocalReferenceError,
            VMInvariantViolationError::StorageError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VMInvariantViolationError", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VMInvariantViolationError {
}

impl ::std::default::Default for VMInvariantViolationError {
    fn default() -> Self {
        VMInvariantViolationError::UnknownInvariantViolationError
    }
}

impl ::protobuf::reflect::ProtobufValue for VMInvariantViolationError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BinaryError {
    UnknownBinaryError = 0,
    Malformed = 1,
    BadMagic = 2,
    UnknownVersion = 3,
    UnknownTableType = 4,
    UnknownSignatureType = 5,
    UnknownSerializedType = 6,
    UnknownOpcode = 7,
    BadHeaderTable = 8,
    UnexpectedSignatureType = 9,
    DuplicateTable = 10,
}

impl ::protobuf::ProtobufEnum for BinaryError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BinaryError> {
        match value {
            0 => ::std::option::Option::Some(BinaryError::UnknownBinaryError),
            1 => ::std::option::Option::Some(BinaryError::Malformed),
            2 => ::std::option::Option::Some(BinaryError::BadMagic),
            3 => ::std::option::Option::Some(BinaryError::UnknownVersion),
            4 => ::std::option::Option::Some(BinaryError::UnknownTableType),
            5 => ::std::option::Option::Some(BinaryError::UnknownSignatureType),
            6 => ::std::option::Option::Some(BinaryError::UnknownSerializedType),
            7 => ::std::option::Option::Some(BinaryError::UnknownOpcode),
            8 => ::std::option::Option::Some(BinaryError::BadHeaderTable),
            9 => ::std::option::Option::Some(BinaryError::UnexpectedSignatureType),
            10 => ::std::option::Option::Some(BinaryError::DuplicateTable),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BinaryError] = &[
            BinaryError::UnknownBinaryError,
            BinaryError::Malformed,
            BinaryError::BadMagic,
            BinaryError::UnknownVersion,
            BinaryError::UnknownTableType,
            BinaryError::UnknownSignatureType,
            BinaryError::UnknownSerializedType,
            BinaryError::UnknownOpcode,
            BinaryError::BadHeaderTable,
            BinaryError::UnexpectedSignatureType,
            BinaryError::DuplicateTable,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BinaryError", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BinaryError {
}

impl ::std::default::Default for BinaryError {
    fn default() -> Self {
        BinaryError::UnknownBinaryError
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RuntimeStatus {
    UnknownRuntimeStatus = 0,
    Executed = 1,
    OutOfGas = 2,
    ResourceDoesNotExist = 3,
    ResourceAlreadyExists = 4,
    EvictedAccountAccess = 5,
    AccountAddressAlreadyExists = 6,
    TypeError = 7,
    MissingData = 8,
    DataFormatError = 9,
    InvalidData = 10,
    RemoteDataError = 11,
    CannotWriteExistingResource = 12,
    ValueSerializationError = 13,
    ValueDeserializationError = 14,
    DuplicateModuleName = 15,
}

impl ::protobuf::ProtobufEnum for RuntimeStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RuntimeStatus> {
        match value {
            0 => ::std::option::Option::Some(RuntimeStatus::UnknownRuntimeStatus),
            1 => ::std::option::Option::Some(RuntimeStatus::Executed),
            2 => ::std::option::Option::Some(RuntimeStatus::OutOfGas),
            3 => ::std::option::Option::Some(RuntimeStatus::ResourceDoesNotExist),
            4 => ::std::option::Option::Some(RuntimeStatus::ResourceAlreadyExists),
            5 => ::std::option::Option::Some(RuntimeStatus::EvictedAccountAccess),
            6 => ::std::option::Option::Some(RuntimeStatus::AccountAddressAlreadyExists),
            7 => ::std::option::Option::Some(RuntimeStatus::TypeError),
            8 => ::std::option::Option::Some(RuntimeStatus::MissingData),
            9 => ::std::option::Option::Some(RuntimeStatus::DataFormatError),
            10 => ::std::option::Option::Some(RuntimeStatus::InvalidData),
            11 => ::std::option::Option::Some(RuntimeStatus::RemoteDataError),
            12 => ::std::option::Option::Some(RuntimeStatus::CannotWriteExistingResource),
            13 => ::std::option::Option::Some(RuntimeStatus::ValueSerializationError),
            14 => ::std::option::Option::Some(RuntimeStatus::ValueDeserializationError),
            15 => ::std::option::Option::Some(RuntimeStatus::DuplicateModuleName),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RuntimeStatus] = &[
            RuntimeStatus::UnknownRuntimeStatus,
            RuntimeStatus::Executed,
            RuntimeStatus::OutOfGas,
            RuntimeStatus::ResourceDoesNotExist,
            RuntimeStatus::ResourceAlreadyExists,
            RuntimeStatus::EvictedAccountAccess,
            RuntimeStatus::AccountAddressAlreadyExists,
            RuntimeStatus::TypeError,
            RuntimeStatus::MissingData,
            RuntimeStatus::DataFormatError,
            RuntimeStatus::InvalidData,
            RuntimeStatus::RemoteDataError,
            RuntimeStatus::CannotWriteExistingResource,
            RuntimeStatus::ValueSerializationError,
            RuntimeStatus::ValueDeserializationError,
            RuntimeStatus::DuplicateModuleName,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RuntimeStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RuntimeStatus {
}

impl ::std::default::Default for RuntimeStatus {
    fn default() -> Self {
        RuntimeStatus::UnknownRuntimeStatus
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fvm_errors.proto\x12\x05types\x1a\x16language_storage.proto\"a\n\
    \x12VMValidationStatus\x121\n\x04code\x18\x01\x20\x01(\x0e2\x1d.types.VM\
    ValidationStatusCodeR\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\
    \x07message\"X\n\x18VMVerificationStatusList\x12<\n\x0bstatus_list\x18\
    \x01\x20\x03(\x0b2\x1b.types.VMVerificationStatusR\nstatusList\"\xc3\x02\
    \n\x14VMVerificationStatus\x12G\n\x0bstatus_kind\x18\x01\x20\x01(\x0e2&.\
    types.VMVerificationStatus.StatusKindR\nstatusKind\x12\x1d\n\nmodule_idx\
    \x18\x02\x20\x01(\rR\tmoduleIdx\x12=\n\nerror_kind\x18\x03\x20\x01(\x0e2\
    \x1e.types.VMVerificationErrorKindR\terrorKind\x12\x18\n\x07message\x18\
    \x04\x20\x01(\tR\x07message\x124\n\rdependency_id\x18\x05\x20\x01(\x0b2\
    \x0f.types.ModuleIdR\x0cdependencyId\"4\n\nStatusKind\x12\n\n\x06SCRIPT\
    \x10\0\x12\n\n\x06MODULE\x10\x01\x12\x0e\n\nDEPENDENCY\x10\x02\"D\n\x10A\
    ssertionFailure\x120\n\x14assertion_error_code\x18\x01\x20\x01(\x04R\x12\
    assertionErrorCode\"\xc0\x01\n\x0fArithmeticError\x12I\n\nerror_code\x18\
    \x01\x20\x01(\x0e2*.types.ArithmeticError.ArithmeticErrorTypeR\terrorCod\
    e\"b\n\x13ArithmeticErrorType\x12\x1a\n\x16UnknownArithmeticError\x10\0\
    \x12\r\n\tUnderflow\x10\x01\x12\x0c\n\x08Overflow\x10\x02\x12\x12\n\x0eD\
    ivisionByZero\x10\x03\"\x9a\x02\n\x15DynamicReferenceError\x12U\n\nerror\
    _code\x18\x01\x20\x01(\x0e26.types.DynamicReferenceError.DynamicReferenc\
    eErrorTypeR\terrorCode\"\xa9\x01\n\x19DynamicReferenceErrorType\x12\x20\
    \n\x1cUnknownDynamicReferenceError\x10\0\x12\x1a\n\x16MoveOfBorrowedReso\
    urce\x10\x01\x12\x1c\n\x18GlobalRefAlreadyReleased\x10\x02\x12\x15\n\x11\
    MissingReleaseRef\x10\x03\x12\x19\n\x15GlobalAlreadyBorrowed\x10\x04\"\
    \xba\x02\n\x0fExecutionStatus\x12=\n\x0eruntime_status\x18\x01\x20\x01(\
    \x0e2\x14.types.RuntimeStatusH\0R\rruntimeStatus\x12F\n\x11assertion_fai\
    lure\x18\x02\x20\x01(\x0b2\x17.types.AssertionFailureH\0R\x10assertionFa\
    ilure\x12C\n\x10arithmetic_error\x18\x03\x20\x01(\x0b2\x16.types.Arithme\
    ticErrorH\0R\x0farithmeticError\x12G\n\x0freference_error\x18\x04\x20\
    \x01(\x0b2\x1c.types.DynamicReferenceErrorH\0R\x0ereferenceErrorB\x12\n\
    \x10execution_status\"\xe9\x02\n\x08VMStatus\x12;\n\nvalidation\x18\x01\
    \x20\x01(\x0b2\x19.types.VMValidationStatusH\0R\nvalidation\x12E\n\x0cve\
    rification\x18\x02\x20\x01(\x0b2\x1f.types.VMVerificationStatusListH\0R\
    \x0cverification\x12S\n\x13invariant_violation\x18\x03\x20\x01(\x0e2\x20\
    .types.VMInvariantViolationErrorH\0R\x12invariantViolation\x12>\n\x0fdes\
    erialization\x18\x04\x20\x01(\x0e2\x12.types.BinaryErrorH\0R\x0fdeserial\
    ization\x126\n\texecution\x18\x05\x20\x01(\x0b2\x16.types.ExecutionStatu\
    sH\0R\texecutionB\x0c\n\nerror_type*\xf8\x03\n\x16VMValidationStatusCode\
    \x12\x1b\n\x17UnknownValidationStatus\x10\0\x12\x14\n\x10InvalidSignatur\
    e\x10\x01\x12\x12\n\x0eInvalidAuthKey\x10\x02\x12\x18\n\x14SequenceNumbe\
    rTooOld\x10\x03\x12\x18\n\x14SequenceNumberTooNew\x10\x04\x12(\n$Insuffi\
    cientBalanceForTransactionFee\x10\x05\x12\x16\n\x12TransactionExpired\
    \x10\x06\x12\x1e\n\x1aSendingAccountDoesNotExist\x10\x07\x12\x14\n\x10Re\
    jectedWriteSet\x10\x08\x12\x13\n\x0fInvalidWriteSet\x10\t\x12\x1e\n\x1aE\
    xceededMaxTransactionSize\x10\n\x12\x11\n\rUnknownScript\x10\x0b\x12\x11\
    \n\rUnknownModule\x10\x0c\x12&\n\"MaxGasUnitsExceedsMaxGasUnitsBound\x10\
    \r\x12*\n&MaxGasUnitsBelowMinTransactionGasUnits\x10\x0e\x12\x1d\n\x19Ga\
    sUnitPriceBelowMinBound\x10\x0f\x12\x1d\n\x19GasUnitPriceAboveMaxBound\
    \x10\x10*\xc6\x0f\n\x17VMVerificationErrorKind\x12\x1c\n\x18UnknownVerif\
    icationError\x10\0\x12\x14\n\x10IndexOutOfBounds\x10\x01\x12\x14\n\x10Ra\
    ngeOutOfBounds\x10\x02\x12\x19\n\x15InvalidSignatureToken\x10\x03\x12\
    \x1c\n\x18InvalidFieldDefReference\x10\x04\x12\x1d\n\x19RecursiveStructD\
    efinition\x10\x05\x12\x18\n\x14InvalidResourceField\x10\x06\x12\x16\n\
    \x12InvalidFallThrough\x10\x07\x12\x0f\n\x0bJoinFailure\x10\x08\x12\x20\
    \n\x1cNegativeStackSizeWithinBlock\x10\t\x12\x13\n\x0fUnbalancedStack\
    \x10\n\x12\x20\n\x1cInvalidMainFunctionSignature\x10\x0b\x12\x14\n\x10Du\
    plicateElement\x10\x0c\x12\x17\n\x13InvalidModuleHandle\x10\r\x12\x17\n\
    \x13UnimplementedHandle\x10\x0e\x12\x16\n\x12InconsistentFields\x10\x0f\
    \x12\x10\n\x0cUnusedFields\x10\x10\x12\x10\n\x0cLookupFailed\x10\x11\x12\
    \x16\n\x12VisibilityMismatch\x10\x12\x12\x19\n\x15TypeResolutionFailure\
    \x10\x13\x12\x10\n\x0cTypeMismatch\x10\x14\x12\x15\n\x11MissingDependenc\
    y\x10\x15\x12\x15\n\x11PopReferenceError\x10\x16\x12\x14\n\x10PopResourc\
    eError\x10\x17\x12\x1f\n\x1bReleaseRefTypeMismatchError\x10\x18\x12\x17\
    \n\x13BrTypeMismatchError\x10\x19\x12\x1b\n\x17AssertTypeMismatchError\
    \x10\x1a\x12\x1a\n\x16StLocTypeMismatchError\x10\x1b\x12\x1d\n\x19StLocU\
    nsafeToDestroyError\x10\x1c\x12\x1b\n\x17RetUnsafeToDestroyError\x10\x1d\
    \x12\x18\n\x14RetTypeMismatchError\x10\x1e\x12\x1e\n\x1aFreezeRefTypeMis\
    matchError\x10\x1f\x12%\n!FreezeRefExistsMutableBorrowError\x10\x20\x12\
    \x20\n\x1cBorrowFieldTypeMismatchError\x10!\x12\x1c\n\x18BorrowFieldBadF\
    ieldError\x10\"\x12'\n#BorrowFieldExistsMutableBorrowError\x10#\x12\x1b\
    \n\x17CopyLocUnavailableError\x10$\x12\x18\n\x14CopyLocResourceError\x10\
    %\x12\x1c\n\x18CopyLocExistsBorrowError\x10&\x12\x1b\n\x17MoveLocUnavail\
    ableError\x10'\x12\x1c\n\x18MoveLocExistsBorrowError\x10(\x12\x1b\n\x17B\
    orrowLocReferenceError\x10)\x12\x1d\n\x19BorrowLocUnavailableError\x10*\
    \x12\x1e\n\x1aBorrowLocExistsBorrowError\x10+\x12\x19\n\x15CallTypeMisma\
    tchError\x10,\x12%\n!CallBorrowedMutableReferenceError\x10-\x12\x19\n\
    \x15PackTypeMismatchError\x10.\x12\x1b\n\x17UnpackTypeMismatchError\x10/\
    \x12\x1c\n\x18ReadRefTypeMismatchError\x100\x12\x18\n\x14ReadRefResource\
    Error\x101\x12#\n\x1fReadRefExistsMutableBorrowError\x102\x12\x1d\n\x19W\
    riteRefTypeMismatchError\x103\x12\x19\n\x15WriteRefResourceError\x104\
    \x12\x1d\n\x19WriteRefExistsBorrowError\x105\x12#\n\x1fWriteRefNoMutable\
    ReferenceError\x106\x12\x1e\n\x1aIntegerOpTypeMismatchError\x107\x12\x1e\
    \n\x1aBooleanOpTypeMismatchError\x108\x12\x1f\n\x1bEqualityOpTypeMismatc\
    hError\x109\x12#\n\x1fExistsResourceTypeMismatchError\x10:\x12!\n\x1dBor\
    rowGlobalTypeMismatchError\x10;\x12\x1f\n\x1bBorrowGlobalNoResourceError\
    \x10<\x12\x1d\n\x19MoveFromTypeMismatchError\x10=\x12\x1b\n\x17MoveFromN\
    oResourceError\x10>\x12!\n\x1dMoveToSenderTypeMismatchError\x10?\x12\x1f\
    \n\x1bMoveToSenderNoResourceError\x10@\x12\"\n\x1eCreateAccountTypeMisma\
    tchError\x10A\x12#\n\x1fModuleAddressDoesNotMatchSender\x10B\x12\x13\n\
    \x0fNoModuleHandles\x10C*\xe0\x01\n\x19VMInvariantViolationError\x12\"\n\
    \x1eUnknownInvariantViolationError\x10\0\x12\x14\n\x10OutOfBoundsIndex\
    \x10\x01\x12\x14\n\x10OutOfBoundsRange\x10\x02\x12\x13\n\x0fEmptyValueSt\
    ack\x10\x03\x12\x12\n\x0eEmptyCallStack\x10\x04\x12\x0e\n\nPCOverflow\
    \x10\x05\x12\x0f\n\x0bLinkerError\x10\x06\x12\x17\n\x13LocalReferenceErr\
    or\x10\x07\x12\x10\n\x0cStorageError\x10\x08*\xf9\x01\n\x0bBinaryError\
    \x12\x16\n\x12UnknownBinaryError\x10\0\x12\r\n\tMalformed\x10\x01\x12\
    \x0c\n\x08BadMagic\x10\x02\x12\x12\n\x0eUnknownVersion\x10\x03\x12\x14\n\
    \x10UnknownTableType\x10\x04\x12\x18\n\x14UnknownSignatureType\x10\x05\
    \x12\x19\n\x15UnknownSerializedType\x10\x06\x12\x11\n\rUnknownOpcode\x10\
    \x07\x12\x12\n\x0eBadHeaderTable\x10\x08\x12\x1b\n\x17UnexpectedSignatur\
    eType\x10\t\x12\x12\n\x0eDuplicateTable\x10\n*\x86\x03\n\rRuntimeStatus\
    \x12\x18\n\x14UnknownRuntimeStatus\x10\0\x12\x0c\n\x08Executed\x10\x01\
    \x12\x0c\n\x08OutOfGas\x10\x02\x12\x18\n\x14ResourceDoesNotExist\x10\x03\
    \x12\x19\n\x15ResourceAlreadyExists\x10\x04\x12\x18\n\x14EvictedAccountA\
    ccess\x10\x05\x12\x1f\n\x1bAccountAddressAlreadyExists\x10\x06\x12\r\n\t\
    TypeError\x10\x07\x12\x0f\n\x0bMissingData\x10\x08\x12\x13\n\x0fDataForm\
    atError\x10\t\x12\x0f\n\x0bInvalidData\x10\n\x12\x13\n\x0fRemoteDataErro\
    r\x10\x0b\x12\x1f\n\x1bCannotWriteExistingResource\x10\x0c\x12\x1b\n\x17\
    ValueSerializationError\x10\r\x12\x1d\n\x19ValueDeserializationError\x10\
    \x0e\x12\x17\n\x13DuplicateModuleName\x10\x0fb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
